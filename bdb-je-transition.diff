diff --git a/pom.xml b/pom.xml
index f1cb669..14509b2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,69 +1,95 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                       http://maven.apache.org/xsd/maven-4.0.0.xsd">
 	<modelVersion>4.0.0</modelVersion>
-  <groupId>org.hypergraphdb</groupId>
-  <artifactId>hgdbfull</artifactId>
-  <name>HyperGraphDB Core</name>
-  <version>1.0</version>  
-  <url>http://code.google.com/p/hypergraphdb</url>
-    
-  <dependencies>
-	<dependency>
-	  <groupId>jivesoftware</groupId>
-	  <artifactId>smack</artifactId>
-	  <version>3.1.0</version>
-	</dependency>  
-	<dependency>
-	  <groupId>jivesoftware</groupId>
-	  <artifactId>smackx</artifactId>
-	  <version>3.1.0</version>
-	</dependency>
-	<dependency>
-		<groupId>berkeleydb</groupId>
-		<artifactId>berkeleydb</artifactId>
-		<version>4.7.25</version>
-	</dependency>
-	<dependency>
-		<groupId>net.jxta</groupId>
-		<artifactId>jxta</artifactId>
-		<version>2.5</version>
-	</dependency>
-  </dependencies>
-  
-  <build>
-    <directory>target</directory>
-    <outputDirectory>target/classes</outputDirectory>
-    <finalName>${artifactId}-${version}</finalName>
-    <testOutputDirectory>target/test-classes</testOutputDirectory>
-    <sourceDirectory>src/java</sourceDirectory>
-    <!--
-    <scriptSourceDirectory>src/config</scriptSourceDirectory>
-    -->
-    <testSourceDirectory>../test/java</testSourceDirectory>
-    <resources>
-      <resource>
-        <directory>src/config</directory>
-      </resource>
-    </resources>
-    <plugins>
-    	<plugin>
-    		<groupId>org.apache.maven.plugins</groupId>
-    		<artifactId>maven-compiler-plugin</artifactId>
-    		<version>2.0.2</version>
-	        <configuration>
-	          <source>1.5</source>
-	          <target>1.5</target>
-	        </configuration>    		
-    	</plugin>
-    </plugins>
-  <!--
-    <testResources>
-      <testResource>
-        <directory>src/test/resources</directory>
-      </testResource>
-    </testResources>
-    -->
-  </build>
+	<groupId>org.hypergraphdb</groupId>
+	<artifactId>hgdbfull</artifactId>
+	<name>HyperGraphDB Core</name>
+	<version>1.0</version>
+	<url>http://code.google.com/p/hypergraphdb</url>
+
+	<dependencies>
+		<dependency>
+			<groupId>jivesoftware</groupId>
+			<artifactId>smack</artifactId>
+			<version>3.1.0</version>
+		</dependency>
+		<dependency>
+			<groupId>jivesoftware</groupId>
+			<artifactId>smackx</artifactId>
+			<version>3.1.0</version>
+		</dependency>
+		<dependency>
+			<groupId>jxta</groupId>
+			<artifactId>jxta</artifactId>
+			<version>2.0</version>
+		</dependency>
+		<dependency>
+			<groupId>com.sleepycat</groupId>
+			<artifactId>je</artifactId>
+			<version>5.0.34</version>
+		</dependency>
+	</dependencies>
+	<repositories>
+		<repository>
+			<id>disyInternal</id>
+			<name>Internal Repository for the Distributed System Group</name>
+			<url>http://mavenrepo.disy.inf.uni-konstanz.de/repository/disyInternal</url>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>false</enabled>
+			</snapshots>
+		</repository>
+		<repository>
+			<id>disyInternalSnapshot</id>
+			<name>Internal Snapshot Repository for the Distributed System Group</name>
+			<url>http://mavenrepo.disy.inf.uni-konstanz.de/repository/disyInternalSnapshot</url>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>true</enabled>
+			</snapshots>
+		</repository>
+		<repository>
+			<id>disyThirdParty</id>
+			<name>Repository for third party jar used by disy</name>
+			<url>http://mavenrepo.disy.inf.uni-konstanz.de/repository/disyThirdParty</url>
+			<releases>
+				<enabled>true</enabled>
+			</releases>
+			<snapshots>
+				<enabled>false</enabled>
+			</snapshots>
+		</repository>
+	</repositories>
+	<build>
+		<directory>target</directory>
+		<outputDirectory>target/classes</outputDirectory>
+		<finalName>${artifactId}-${version}</finalName>
+		<testOutputDirectory>target/test-classes</testOutputDirectory>
+		<sourceDirectory>src/java</sourceDirectory>
+		<!-- <scriptSourceDirectory>src/config</scriptSourceDirectory> -->
+		<testSourceDirectory>../test/java</testSourceDirectory>
+		<resources>
+			<resource>
+				<directory>src/config</directory>
+			</resource>
+		</resources>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<version>2.0.2</version>
+				<configuration>
+					<source>1.5</source>
+					<target>1.5</target>
+				</configuration>
+			</plugin>
+		</plugins>
+		<!-- <testResources> <testResource> <directory>src/test/resources</directory> 
+			</testResource> </testResources> -->
+	</build>
 </project>
diff --git a/src/java/org/hypergraphdb/maintenance/ApplyNewIndexer.java b/src/java/org/hypergraphdb/maintenance/ApplyNewIndexer.java
index fda63d9..d0aecb8 100644
--- a/src/java/org/hypergraphdb/maintenance/ApplyNewIndexer.java
+++ b/src/java/org/hypergraphdb/maintenance/ApplyNewIndexer.java
@@ -8,21 +8,20 @@
 package org.hypergraphdb.maintenance;
 
 import java.util.ArrayList;
-
-import java.util.List;
-
-import org.hypergraphdb.HGHandle;
-import org.hypergraphdb.HGIndex;
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.HGRandomAccessResult.GotoResult;
-import org.hypergraphdb.HyperGraph;
-import org.hypergraphdb.HGQuery.hg;
-import org.hypergraphdb.indexing.HGIndexer;
+import java.util.List;
+
+import org.hypergraphdb.HGHandle;
+import org.hypergraphdb.HGIndex;
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.HGQuery.hg;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.HGRandomAccessResult.GotoResult;
+import org.hypergraphdb.HyperGraph;
+import org.hypergraphdb.indexing.HGIndexer;
 import org.hypergraphdb.transaction.TransactionConflictException;
-import org.hypergraphdb.util.HGUtils;
+import org.hypergraphdb.util.HGUtils;
 
-import com.sleepycat.db.DeadlockException;
+import com.sleepycat.je.DeadlockException;
 
 /**
  * 
diff --git a/src/java/org/hypergraphdb/storage/BAUtils.java b/src/java/org/hypergraphdb/storage/BAUtils.java
index 45dbe4a..0105019 100644
--- a/src/java/org/hypergraphdb/storage/BAUtils.java
+++ b/src/java/org/hypergraphdb/storage/BAUtils.java
@@ -5,87 +5,79 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-/**
- * <p>
- * This class contains some utilities methods to read/write primitively typed values from/to
- * a byte buffer.
- * </p>
- *  
- * @author Borislav Iordanov
- */
-public class BAUtils 
-{
-    public static long readLong(byte [] bytes, int offset)
-    {
-        return new Long((((long)bytes[offset] << 56) +
-                ((long)(bytes[offset + 1] & 255) << 48) +
-                ((long)(bytes[offset + 2] & 255) << 40) +
-                ((long)(bytes[offset + 3] & 255) << 32) +
-                ((long)(bytes[offset + 4] & 255) << 24) +
-                ((bytes[offset + 5] & 255) << 16) + 
-                ((bytes[offset + 6] & 255) <<  8) + 
-                ((bytes[offset + 7] & 255) <<  0))); 
+package org.hypergraphdb.storage;
+
+/**
+ * <p>
+ * This class contains some utilities methods to read/write primitively typed
+ * values from/to a byte buffer.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public class BAUtils {
+    public static long readLong(byte[] bytes, int offset) {
+        return new Long(
+                (((long) bytes[offset] << 56)
+                        + ((long) (bytes[offset + 1] & 255) << 48)
+                        + ((long) (bytes[offset + 2] & 255) << 40)
+                        + ((long) (bytes[offset + 3] & 255) << 32)
+                        + ((long) (bytes[offset + 4] & 255) << 24)
+                        + ((bytes[offset + 5] & 255) << 16)
+                        + ((bytes[offset + 6] & 255) << 8) + ((bytes[offset + 7] & 255) << 0)));
     }
-    
-    public static void writeLong(long v, byte [] data, int offset)
-    {
-        data[offset] = (byte) ((v >>> 56)); 
+
+    public static void writeLong(long v, byte[] data, int offset) {
+        data[offset] = (byte) ((v >>> 56));
         data[offset + 1] = (byte) ((v >>> 48));
-        data[offset + 2] = (byte) ((v >>> 40)); 
+        data[offset + 2] = (byte) ((v >>> 40));
         data[offset + 3] = (byte) ((v >>> 32));
-        data[offset + 4] = (byte) ((v >>> 24)); 
+        data[offset + 4] = (byte) ((v >>> 24));
         data[offset + 5] = (byte) ((v >>> 16));
-        data[offset + 6] = (byte) ((v >>> 8)); 
+        data[offset + 6] = (byte) ((v >>> 8));
         data[offset + 7] = (byte) ((v >>> 0));
     }
-    
-	public static int readInt(byte [] buffer, int offset)
-	{
-        int ch1 = buffer[offset];
-        int ch2 = buffer[offset + 1];
-        int ch3 = buffer[offset + 2];
-        int ch4 = buffer[offset + 3];
-        return ((ch1 & 0xFF) << 24)
-	      | ((ch2 & 0xFF) << 16)
-	      | ((ch3 & 0xFF) << 8)
-	      | (ch4 & 0xFF);
-	}
-	
-	public static void writeInt(int c, byte [] buffer, int offset)
-	{
-		buffer[offset + 0] = (byte) ((c >>> 24) & 0xFF);
-        buffer[offset + 1] = (byte) ((c >>> 16) & 0xFF);
-        buffer[offset + 2] = (byte) ((c >>> 8) & 0xFF);
-        buffer[offset + 3] = (byte) ((c >>> 0) & 0xFF);		
-	}
-	
-	public static boolean eq(byte [] left, int leftPos, byte [] right, int rightPos, int size)
-	{
-		int i = leftPos, j = rightPos;
-		if (leftPos + size > left.length)
-			return false;
-		if (rightPos + size > right.length)
-			return false;
-		while (size > 0)
-		{
-			if (left[i++] != right[j++])
-				return false;
-			size--;
-		}
-		return true;
-	}
-	
-	public static int compare(byte [] left, int leftPos, byte [] right, int rightPos, int max)
-	{
-		int maxLeft = leftPos + max;
-		int maxRight = rightPos + max;
-		int i = leftPos;
-		int j = rightPos;
-		int comp = 0;
-		while (comp == 0 && i < maxLeft && j < maxRight)
-			comp = left[i++] - right[j++];
-		return comp;
-	}
-}
+
+    public static int readInt(byte[] buffer, int offset) {
+        int ch1 = buffer[offset];
+        int ch2 = buffer[offset + 1];
+        int ch3 = buffer[offset + 2];
+        int ch4 = buffer[offset + 3];
+        return ((ch1 & 0xFF) << 24) | ((ch2 & 0xFF) << 16)
+                | ((ch3 & 0xFF) << 8) | (ch4 & 0xFF);
+    }
+
+    public static void writeInt(int c, byte[] buffer, int offset) {
+        buffer[offset + 0] = (byte) ((c >>> 24) & 0xFF);
+        buffer[offset + 1] = (byte) ((c >>> 16) & 0xFF);
+        buffer[offset + 2] = (byte) ((c >>> 8) & 0xFF);
+        buffer[offset + 3] = (byte) ((c >>> 0) & 0xFF);
+    }
+
+    public static boolean eq(byte[] left, int leftPos, byte[] right,
+            int rightPos, int size) {
+        int i = leftPos, j = rightPos;
+        if (leftPos + size > left.length)
+            return false;
+        if (rightPos + size > right.length)
+            return false;
+        while (size > 0) {
+            if (left[i++] != right[j++])
+                return false;
+            size--;
+        }
+        return true;
+    }
+
+    public static int compare(byte[] left, int leftPos, byte[] right,
+            int rightPos, int max) {
+        int maxLeft = leftPos + max;
+        int maxRight = rightPos + max;
+        int i = leftPos;
+        int j = rightPos;
+        int comp = 0;
+        while (comp == 0 && i < maxLeft && j < maxRight)
+            comp = left[i++] - right[j++];
+        return comp;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/BAtoBA.java b/src/java/org/hypergraphdb/storage/BAtoBA.java
index edecaa2..ca5f1a9 100644
--- a/src/java/org/hypergraphdb/storage/BAtoBA.java
+++ b/src/java/org/hypergraphdb/storage/BAtoBA.java
@@ -5,24 +5,20 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-public class BAtoBA implements ByteArrayConverter<byte[]>
-{
-    private static final BAtoBA instance = new BAtoBA();
-    
-    public static ByteArrayConverter<byte[]> getInstance()
-    {
-        return instance;
-    }
-    
-    public byte[] toByteArray(byte [] object)
-    {
-        return (byte[])object;
-    }
-
-    public byte [] fromByteArray(byte[] byteArray)
-    {
-        return byteArray;
-    }
-}
+package org.hypergraphdb.storage;
+
+public class BAtoBA implements ByteArrayConverter<byte[]> {
+    private static final BAtoBA instance = new BAtoBA();
+
+    public static ByteArrayConverter<byte[]> getInstance() {
+        return instance;
+    }
+
+    public byte[] toByteArray(byte[] object) {
+        return (byte[]) object;
+    }
+
+    public byte[] fromByteArray(byte[] byteArray) {
+        return byteArray;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/BAtoHandle.java b/src/java/org/hypergraphdb/storage/BAtoHandle.java
index 58e8a75..734a7ea 100644
--- a/src/java/org/hypergraphdb/storage/BAtoHandle.java
+++ b/src/java/org/hypergraphdb/storage/BAtoHandle.java
@@ -5,42 +5,36 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
+package org.hypergraphdb.storage;
+
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hypergraphdb.HGHandleFactory;
+import org.hypergraphdb.HGPersistentHandle;
+
+public class BAtoHandle implements ByteArrayConverter<HGPersistentHandle> {
+    private static final Map<HGHandleFactory, BAtoHandle> M = new HashMap<HGHandleFactory, BAtoHandle>();
 
-import org.hypergraphdb.HGPersistentHandle;
-
-public class BAtoHandle implements ByteArrayConverter<HGPersistentHandle>
-{
-    private static final Map<HGHandleFactory, BAtoHandle> M = 
-        new HashMap<HGHandleFactory, BAtoHandle>();
-    
     private HGHandleFactory handleFactory = null;
-    
-    public synchronized static ByteArrayConverter<HGPersistentHandle> getInstance(HGHandleFactory handleFactory)
-    {
+
+    public synchronized static ByteArrayConverter<HGPersistentHandle> getInstance(
+            HGHandleFactory handleFactory) {
         BAtoHandle instance = M.get(handleFactory);
-        if (instance == null)
-        {
+        if (instance == null) {
             instance = new BAtoHandle();
             instance.handleFactory = handleFactory;
             M.put(handleFactory, instance);
-        }
-        return instance;
-    }
-    
-    public byte[] toByteArray(HGPersistentHandle object)
-    {
-        return object.toByteArray();
-    }
-
-    public HGPersistentHandle fromByteArray(byte[] byteArray)
-    {
-        return handleFactory.makeHandle(byteArray);
-//        return UUIDPersistentHandle.makeHandle(byteArray);
-    }
+        }
+        return instance;
+    }
+
+    public byte[] toByteArray(HGPersistentHandle object) {
+        return object.toByteArray();
+    }
+
+    public HGPersistentHandle fromByteArray(byte[] byteArray) {
+        return handleFactory.makeHandle(byteArray);
+        // return UUIDPersistentHandle.makeHandle(byteArray);
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/BAtoString.java b/src/java/org/hypergraphdb/storage/BAtoString.java
index 55ce7c1..cb3c666 100644
--- a/src/java/org/hypergraphdb/storage/BAtoString.java
+++ b/src/java/org/hypergraphdb/storage/BAtoString.java
@@ -5,21 +5,20 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-public class BAtoString implements ByteArrayConverter<String> 
-{
-	private static final BAtoString the_instance = new BAtoString();
-	
-	public static BAtoString getInstance() { return the_instance; }
-	
-	public byte[] toByteArray(String object) 
-	{
-		return object.getBytes();
-	}
-
-	public String fromByteArray(byte[] byteArray) 
-	{
-		return new String(byteArray);
-	}
-}
+package org.hypergraphdb.storage;
+
+public class BAtoString implements ByteArrayConverter<String> {
+    private static final BAtoString the_instance = new BAtoString();
+
+    public static BAtoString getInstance() {
+        return the_instance;
+    }
+
+    public byte[] toByteArray(String object) {
+        return object.getBytes();
+    }
+
+    public String fromByteArray(byte[] byteArray) {
+        return new String(byteArray);
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/BDBConfig.java b/src/java/org/hypergraphdb/storage/BDBConfig.java
index f5f7276..36b23a6 100644
--- a/src/java/org/hypergraphdb/storage/BDBConfig.java
+++ b/src/java/org/hypergraphdb/storage/BDBConfig.java
@@ -1,87 +1,49 @@
 package org.hypergraphdb.storage;
 
-import com.sleepycat.db.DatabaseConfig;
-import com.sleepycat.db.DatabaseType;
-import com.sleepycat.db.EnvironmentConfig;
-import com.sleepycat.db.LockDetectMode;
+import com.sleepycat.je.DatabaseConfig;
+import com.sleepycat.je.EnvironmentConfig;
+
+public class BDBConfig {
+    public static final long DEFAULT_STORE_CACHE = 20 * 1024 * 1024; // 20MB
+    public static final int DEFAULT_NUMBER_OF_STORAGE_CACHES = 1;
 
-public class BDBConfig
-{
-    public static final long DEFAULT_STORE_CACHE = 20*1024*1024; // 20MB
-    public static final int  DEFAULT_NUMBER_OF_STORAGE_CACHES = 1;
-        
     private EnvironmentConfig envConfig;
     private DatabaseConfig dbConfig;
     private boolean storageMVCC = true;
-    
-    private void resetDefaults()
-    {
+
+    private void resetDefaults() {
         envConfig.setAllowCreate(true);
-        envConfig.setInitializeCache(true);  
         envConfig.setCacheSize(DEFAULT_STORE_CACHE);
-        envConfig.setCacheCount(DEFAULT_NUMBER_OF_STORAGE_CACHES);
-        envConfig.setErrorPrefix("BERKELEYDB");
-        envConfig.setErrorStream(System.out);          
-        
+
         dbConfig.setAllowCreate(true);
-        dbConfig.setType(DatabaseType.BTREE);
     }
-    
-    public BDBConfig()
-    {
+
+    public BDBConfig() {
         envConfig = new EnvironmentConfig();
         dbConfig = new DatabaseConfig();
         resetDefaults();
     }
-    
-    public EnvironmentConfig getEnvironmentConfig()
-    {
+
+    public EnvironmentConfig getEnvironmentConfig() {
         return envConfig;
     }
-    
-    public DatabaseConfig getDatabaseConfig()
-    {
+
+    public DatabaseConfig getDatabaseConfig() {
         return dbConfig;
     }
 
-    public void configureTransactional()
-    {
-        envConfig.setInitializeLogging(true);
-        envConfig.setTransactional(true);            
-        if (!storageMVCC)
-        {
-            envConfig.setInitializeLocking(true);
-            envConfig.setLockDetectMode(LockDetectMode.RANDOM);
-            envConfig.setMaxLockers(2000);
-            envConfig.setMaxLockObjects(20000);
-            envConfig.setMaxLocks(20000);                
-        }
-        else
-        {
-            envConfig.setMultiversion(true);
-            envConfig.setTxnSnapshot(true);
-        }
+    public void configureTransactional() {
+        envConfig.setTransactional(true);
+
         envConfig.setTxnWriteNoSync(true);
-        envConfig.setCachePageSize(4*1024);
-        long maxActive = envConfig.getCacheSize() / envConfig.getCachePageSize();
-        envConfig.setTxnMaxActive((int)maxActive*10);                   
-        envConfig.setRunRecovery(true);
-        envConfig.setRegister(true);
-        envConfig.setLogAutoRemove(true);
-//          envConfig.setMaxMutexes(10000);
-//        envConfig.setRunFatalRecovery(true);
-        dbConfig.setTransactional(true);            
-        if (storageMVCC)
-            dbConfig.setMultiversion(true);
+        dbConfig.setTransactional(true);
     }
-    
-    public boolean isStorageMVCC()
-    {
+
+    public boolean isStorageMVCC() {
         return storageMVCC;
     }
 
-    public void setStorageMVCC(boolean storageMVCC)
-    {
+    public void setStorageMVCC(boolean storageMVCC) {
         this.storageMVCC = storageMVCC;
-    }    
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/BDBStorageImplementation.java b/src/java/org/hypergraphdb/storage/BDBStorageImplementation.java
index ef88372..20ab01d 100644
--- a/src/java/org/hypergraphdb/storage/BDBStorageImplementation.java
+++ b/src/java/org/hypergraphdb/storage/BDBStorageImplementation.java
@@ -1,7 +1,6 @@
 package org.hypergraphdb.storage;
 
 import java.io.File;
-
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -23,40 +22,24 @@ import org.hypergraphdb.transaction.HGTransactionFactory;
 import org.hypergraphdb.transaction.TransactionBDBImpl;
 import org.hypergraphdb.transaction.VanillaTransaction;
 
-import com.sleepycat.db.Cursor;
-import com.sleepycat.db.CursorConfig;
-import com.sleepycat.db.Database;
-import com.sleepycat.db.DatabaseConfig;
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.Environment;
-import com.sleepycat.db.EnvironmentConfig;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-import com.sleepycat.db.Transaction;
-import com.sleepycat.db.TransactionConfig;
-
-public class BDBStorageImplementation implements HGStoreImplementation
-{
+import com.sleepycat.je.Cursor;
+import com.sleepycat.je.CursorConfig;
+import com.sleepycat.je.Database;
+import com.sleepycat.je.DatabaseConfig;
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.Environment;
+import com.sleepycat.je.EnvironmentConfig;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+import com.sleepycat.je.Transaction;
+import com.sleepycat.je.TransactionConfig;
+
+public class BDBStorageImplementation implements HGStoreImplementation {
     private static final String DATA_DB_NAME = "datadb";
     private static final String PRIMITIVE_DB_NAME = "primitivedb";
     private static final String INCIDENCE_DB_NAME = "incidencedb";
-     
-    static
-    {
-        // This is solely because of failing to resolve dependencies under 
-        // Windows. For some reason, when libdb50 is loaded explicitly first,
-        // it all works out fine.
-        if (System.getProperty("os.name").toLowerCase().indexOf("win") > -1)
-        {
-          System.loadLibrary("libdb50");
-          System.loadLibrary("libdb_java50");
-        	
-//            System.loadLibrary("libdb51");
-//            System.loadLibrary("libdb_java51");
-        }
-    }
-    
+
     private BDBConfig configuration;
     private HGStore store;
     private HGHandleFactory handleFactory;
@@ -65,36 +48,34 @@ public class BDBStorageImplementation implements HGStoreImplementation
     private Database data_db = null;
     private Database primitive_db = null;
     private Database incidence_db = null;
-    private HashMap<String, HGIndex<?,?>> openIndices = new HashMap<String, HGIndex<?,?>>();
-    private ReentrantReadWriteLock indicesLock = new ReentrantReadWriteLock();    
+    private HashMap<String, HGIndex<?, ?>> openIndices = new HashMap<String, HGIndex<?, ?>>();
+    private ReentrantReadWriteLock indicesLock = new ReentrantReadWriteLock();
     private LinkBinding linkBinding = null;
-    
-    private TransactionBDBImpl txn()
-    {
-        HGTransaction tx = store.getTransactionManager().getContext().getCurrent();;
-        if (tx == null || tx.getStorageTransaction() instanceof VanillaTransaction)
+
+    private TransactionBDBImpl txn() {
+        HGTransaction tx = store.getTransactionManager().getContext()
+                .getCurrent();
+        ;
+        if (tx == null
+                || tx.getStorageTransaction() instanceof VanillaTransaction)
             return TransactionBDBImpl.nullTransaction();
         else
-            return (TransactionBDBImpl)tx.getStorageTransaction();
-    }    
-    
-    public BDBStorageImplementation()
-    {
+            return (TransactionBDBImpl) tx.getStorageTransaction();
+    }
+
+    public BDBStorageImplementation() {
         configuration = new BDBConfig();
     }
-    
-    public BDBConfig getConfiguration()
-    {
+
+    public BDBConfig getConfiguration() {
         return configuration;
     }
-    
-    public Environment getBerkleyEnvironment()
-    {
+
+    public Environment getBerkleyEnvironment() {
         return env;
     }
-    
-    public void startup(HGStore store, HGConfiguration config)
-    {
+
+    public void startup(HGStore store, HGConfiguration config) {
         this.store = store;
         this.handleFactory = config.getHandleFactory();
         this.linkBinding = new LinkBinding(handleFactory);
@@ -103,517 +84,486 @@ public class BDBStorageImplementation implements HGStoreImplementation
             configuration.configureTransactional();
         File envDir = new File(store.getDatabaseLocation());
         envDir.mkdirs();
-        try
-        {
+        try {
             env = new Environment(envDir, envConfig);
-            data_db = env.openDatabase(null, DATA_DB_NAME, null, configuration.getDatabaseConfig().cloneConfig());    
-            primitive_db = env.openDatabase(null, PRIMITIVE_DB_NAME, null, configuration.getDatabaseConfig().cloneConfig());
-            
-            DatabaseConfig incConfig = configuration.getDatabaseConfig().cloneConfig();
+            data_db = env.openDatabase(null, DATA_DB_NAME, configuration
+                    .getDatabaseConfig().clone());
+            primitive_db = env.openDatabase(null, PRIMITIVE_DB_NAME,
+                    configuration.getDatabaseConfig().clone());
+
+            DatabaseConfig incConfig = configuration.getDatabaseConfig()
+                    .clone();
             incConfig.setSortedDuplicates(true);
-            incidence_db = env.openDatabase(null, INCIDENCE_DB_NAME, null, incConfig);
-            
-            if (config.isTransactional())
-            {
+            incidence_db = env.openDatabase(null, INCIDENCE_DB_NAME, incConfig);
+
+            if (config.isTransactional()) {
                 checkPointThread = new CheckPointThread();
                 checkPointThread.start();
             }
+        } catch (Exception ex) {
+            throw new HGException(
+                    "Failed to initialize HyperGraph data store: "
+                            + ex.toString(), ex);
         }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to initialize HyperGraph data store: " + ex.toString(), ex);
-        }        
     }
-    
-    public void shutdown()
-    {
-        if (checkPointThread != null)
-        {
+
+    public void shutdown() {
+        if (checkPointThread != null) {
             checkPointThread.stop = true;
             checkPointThread.interrupt();
             while (checkPointThread.running)
-                try { Thread.sleep(500); }
-                catch (InterruptedException ex) { /* need to wait here until it stops... */}
+                try {
+                    Thread.sleep(500);
+                } catch (InterruptedException ex) { /*
+                                                     * need to wait here until
+                                                     * it stops...
+                                                     */
+                }
         }
-        
-        if (env != null)
-        {
-            try
-            {
+
+        if (env != null) {
+            try {
                 if (env.getConfig().getTransactional())
                     env.checkpoint(null);
-            }
-            catch (Throwable t)
-            {
+            } catch (Throwable t) {
                 t.printStackTrace();
             }
-        
+
             //
             // Close all indices
             //
-            for (Iterator<HGIndex<?,?>> i = openIndices.values().iterator(); i.hasNext(); )
-                try
-                {
+            for (Iterator<HGIndex<?, ?>> i = openIndices.values().iterator(); i
+                    .hasNext();)
+                try {
                     i.next().close();
-                }
-                catch (Throwable t)
-                {
-                    // TODO - we need to log the exception here, once we've decided
-                    // on a logging mechanism. 
+                } catch (Throwable t) {
+                    // TODO - we need to log the exception here, once we've
+                    // decided
+                    // on a logging mechanism.
                     t.printStackTrace();
                 }
-            try { data_db.close(); }
-            catch (Throwable t) { t.printStackTrace(); }
-            
-            try { primitive_db.close(); }
-            catch (Throwable t) { t.printStackTrace(); }
-            
-            try { incidence_db.close(); }
-            catch (Throwable t) { t.printStackTrace(); }
-            
-            try { env.close(); }
-            catch (Throwable t) { t.printStackTrace(); }
-        }         
+            try {
+                data_db.close();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+
+            try {
+                primitive_db.close();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+
+            try {
+                incidence_db.close();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+
+            try {
+                env.close();
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        }
     }
-    
-    public void removeLink(HGPersistentHandle handle)
-    {
+
+    public void removeLink(HGPersistentHandle handle) {
         if (handle == null)
-            throw new NullPointerException("HGStore.remove called with a null handle.");
-        try
-        {
+            throw new NullPointerException(
+                    "HGStore.remove called with a null handle.");
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             data_db.delete(txn().getBDBTransaction(), key);
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to remove value with handle " + handle + 
-                    ": " + ex.toString(), ex);            
+        } catch (Exception ex) {
+            throw new HGException("Failed to remove value with handle "
+                    + handle + ": " + ex.toString(), ex);
         }
     }
 
-    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data)
-    {
-        try
-        {
-            OperationStatus result = primitive_db.put(txn().getBDBTransaction(), 
-                                                 new DatabaseEntry(handle.toByteArray()), 
-                                                 new DatabaseEntry(data));
+    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data) {
+        try {
+            OperationStatus result = primitive_db.put(
+                    txn().getBDBTransaction(),
+                    new DatabaseEntry(handle.toByteArray()), new DatabaseEntry(
+                            data));
             if (result != OperationStatus.SUCCESS)
-                throw new Exception("OperationStatus: " + result);            
+                throw new Exception("OperationStatus: " + result);
             return handle;
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to store hypergraph raw byte []: " + ex.toString(), ex);
+        } catch (Exception ex) {
+            throw new HGException("Failed to store hypergraph raw byte []: "
+                    + ex.toString(), ex);
         }
     }
 
-    public HGPersistentHandle store(HGPersistentHandle handle, HGPersistentHandle[] link)
-    {
+    public HGPersistentHandle store(HGPersistentHandle handle,
+            HGPersistentHandle[] link) {
         DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
-        DatabaseEntry value = new DatabaseEntry(); 
+        DatabaseEntry value = new DatabaseEntry();
         linkBinding.objectToEntry(link, value);
-        try
-        {
-            OperationStatus result = data_db.put(txn().getBDBTransaction(), key, value);
+        try {
+            OperationStatus result = data_db.put(txn().getBDBTransaction(),
+                    key, value);
             if (result != OperationStatus.SUCCESS)
-                throw new Exception("OperationStatus: " + result);            
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to store hypergraph link: " + ex.toString(), ex);
+                throw new Exception("OperationStatus: " + result);
+        } catch (Exception ex) {
+            throw new HGException("Failed to store hypergraph link: "
+                    + ex.toString(), ex);
         }
         return handle;
     }
-    
-    public void addIncidenceLink(HGPersistentHandle handle, HGPersistentHandle newLink)
-    {
+
+    public void addIncidenceLink(HGPersistentHandle handle,
+            HGPersistentHandle newLink) {
         Cursor cursor = null;
-        try
-        {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             DatabaseEntry value = new DatabaseEntry(newLink.toByteArray());
-            OperationStatus result = incidence_db.putNoDupData(txn().getBDBTransaction(), key, value);
-            if (result != OperationStatus.SUCCESS && result != OperationStatus.KEYEXIST)
-                throw new Exception("OperationStatus: " + result);            
-            
-//            cursor = incidence_db.openCursor(txn().getBDBTransaction(), cursorConfig);
-//            OperationStatus status = cursor.getSearchBoth(key, value, LockMode.DEFAULT);
-//            if (status == OperationStatus.NOTFOUND)
-//            {
-//                OperationStatus result = incidence_db.put(txn().getBDBTransaction(), key, value);
-//                if (result != OperationStatus.SUCCESS)
-//                    throw new Exception("OperationStatus: " + result);
-//            }
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to update incidence set for handle " + handle + 
-                                  ": " + ex.toString(), ex);
-        }
-        finally
-        {
+            OperationStatus result = incidence_db.putNoDupData(txn()
+                    .getBDBTransaction(), key, value);
+            if (result != OperationStatus.SUCCESS
+                    && result != OperationStatus.KEYEXIST)
+                throw new Exception("OperationStatus: " + result);
+
+            // cursor = incidence_db.openCursor(txn().getBDBTransaction(),
+            // cursorConfig);
+            // OperationStatus status = cursor.getSearchBoth(key, value,
+            // LockMode.DEFAULT);
+            // if (status == OperationStatus.NOTFOUND)
+            // {
+            // OperationStatus result =
+            // incidence_db.put(txn().getBDBTransaction(), key, value);
+            // if (result != OperationStatus.SUCCESS)
+            // throw new Exception("OperationStatus: " + result);
+            // }
+        } catch (Exception ex) {
+            throw new HGException("Failed to update incidence set for handle "
+                    + handle + ": " + ex.toString(), ex);
+        } finally {
             if (cursor != null)
-                try { cursor.close(); } catch (Exception ex) { }
-        }  
+                try {
+                    cursor.close();
+                } catch (Exception ex) {
+                }
+        }
     }
 
-    public boolean containsLink(HGPersistentHandle handle)
-    {        
+    public boolean containsLink(HGPersistentHandle handle) {
         DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
         DatabaseEntry value = new DatabaseEntry();
-        try
-        {
-            if (data_db.get(txn().getBDBTransaction(), key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS)          
-            {
-//                System.out.println(value.toString());
+        try {
+            if (data_db.get(txn().getBDBTransaction(), key, value,
+                    LockMode.DEFAULT) == OperationStatus.SUCCESS) {
+                // System.out.println(value.toString());
                 return true;
             }
-        } catch (DatabaseException ex)
-        {
-            throw new HGException("Failed to retrieve link with handle " + handle + 
-                    ": " + ex.toString(), ex);
-        }      
-        
+        } catch (DatabaseException ex) {
+            throw new HGException("Failed to retrieve link with handle "
+                    + handle + ": " + ex.toString(), ex);
+        }
+
         return false;
     }
 
-    public byte[] getData(HGPersistentHandle handle)
-    {
-        try
-        {            
+    public byte[] getData(HGPersistentHandle handle) {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             DatabaseEntry value = new DatabaseEntry();
-            if (primitive_db.get(txn().getBDBTransaction(), key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS)          
+            if (primitive_db.get(txn().getBDBTransaction(), key, value,
+                    LockMode.DEFAULT) == OperationStatus.SUCCESS)
                 return value.getData();
             else
-                return null;            
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to retrieve link with handle " + handle, ex);
+                return null;
+        } catch (Exception ex) {
+            throw new HGException("Failed to retrieve link with handle "
+                    + handle, ex);
         }
     }
 
     @SuppressWarnings("unchecked")
-    public HGRandomAccessResult<HGPersistentHandle> getIncidenceResultSet(HGPersistentHandle handle)
-    {
+    public HGRandomAccessResult<HGPersistentHandle> getIncidenceResultSet(
+            HGPersistentHandle handle) {
         if (handle == null)
-            throw new NullPointerException("HGStore.getIncidenceSet called with a null handle.");
-        
+            throw new NullPointerException(
+                    "HGStore.getIncidenceSet called with a null handle.");
+
         Cursor cursor = null;
-        try
-        {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             DatabaseEntry value = new DatabaseEntry();
             TransactionBDBImpl tx = txn();
-            cursor = incidence_db.openCursor(tx.getBDBTransaction(), cursorConfig);            
-            OperationStatus status = cursor.getSearchKey(key, value, LockMode.DEFAULT);
-            if (status == OperationStatus.NOTFOUND)
-            {
+            cursor = incidence_db.openCursor(tx.getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchKey(key, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.NOTFOUND) {
                 cursor.close();
-                return (HGRandomAccessResult<HGPersistentHandle>)HGSearchResult.EMPTY;
-            }
-            else
-                return new SingleKeyResultSet(tx.attachCursor(cursor), 
-                                              key, 
-                                              BAtoHandle.getInstance(handleFactory));            
-        }
-        catch (Throwable ex)
-        {
+                return (HGRandomAccessResult<HGPersistentHandle>) HGSearchResult.EMPTY;
+            } else
+                return new SingleKeyResultSet(tx.attachCursor(cursor), key,
+                        BAtoHandle.getInstance(handleFactory));
+        } catch (Throwable ex) {
             if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }                        
-            throw new HGException("Failed to retrieve incidence set for handle " + handle + 
-                                  ": " + ex.toString(), ex);
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException(
+                    "Failed to retrieve incidence set for handle " + handle
+                            + ": " + ex.toString(), ex);
         }
     }
 
-    public long getIncidenceSetCardinality(HGPersistentHandle handle)
-    {
+    public long getIncidenceSetCardinality(HGPersistentHandle handle) {
         if (handle == null)
-            throw new NullPointerException("HGStore.getIncidenceSetCardinality called with a null handle.");
-        
+            throw new NullPointerException(
+                    "HGStore.getIncidenceSetCardinality called with a null handle.");
+
         Cursor cursor = null;
-        try
-        {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
-            DatabaseEntry value = new DatabaseEntry();            
-            cursor = incidence_db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(key, value, LockMode.DEFAULT);
+            DatabaseEntry value = new DatabaseEntry();
+            cursor = incidence_db.openCursor(txn().getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchKey(key, value,
+                    LockMode.DEFAULT);
             if (status == OperationStatus.NOTFOUND)
                 return 0;
             else
                 return cursor.count();
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to retrieve incidence set for handle " + handle + 
-                                  ": " + ex.toString(), ex);
-        }       
-        finally
-        {
-            try { cursor.close(); } catch (Throwable t) { }
+        } catch (Exception ex) {
+            throw new HGException(
+                    "Failed to retrieve incidence set for handle " + handle
+                            + ": " + ex.toString(), ex);
+        } finally {
+            try {
+                cursor.close();
+            } catch (Throwable t) {
+            }
         }
     }
 
-    public HGPersistentHandle[] getLink(HGPersistentHandle handle)
-    {
-        try
-        {           
+    public HGPersistentHandle[] getLink(HGPersistentHandle handle) {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             DatabaseEntry value = new DatabaseEntry();
-            if (data_db.get(txn().getBDBTransaction(), key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS)          
-                return (HGPersistentHandle [])linkBinding.entryToObject(value);
+            if (data_db.get(txn().getBDBTransaction(), key, value,
+                    LockMode.DEFAULT) == OperationStatus.SUCCESS)
+                return (HGPersistentHandle[]) linkBinding.entryToObject(value);
             else
                 return null;
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to retrieve link with handle " + handle, ex);
+        } catch (Exception ex) {
+            throw new HGException("Failed to retrieve link with handle "
+                    + handle, ex);
         }
     }
 
-    public HGTransactionFactory getTransactionFactory()
-    {
-        return new HGTransactionFactory()
-        {
-            public HGStorageTransaction createTransaction(HGTransactionContext context, HGTransactionConfig config, HGTransaction parent)
-            {           
-                try
-                {
+    public HGTransactionFactory getTransactionFactory() {
+        return new HGTransactionFactory() {
+            public HGStorageTransaction createTransaction(
+                    HGTransactionContext context, HGTransactionConfig config,
+                    HGTransaction parent) {
+                try {
                     TransactionConfig tconfig = new TransactionConfig();
-                    if (env.getConfig().getMultiversion() && config.isReadonly())                    
-                        tconfig.setSnapshot(true);
                     tconfig.setWriteNoSync(true);
-//                  tconfig.setNoSync(true);
+                    // tconfig.setNoSync(true);
                     Transaction tx = null;
                     if (parent != null)
-                        tx = env.beginTransaction(((TransactionBDBImpl)parent.getStorageTransaction()).getBDBTransaction(), tconfig);
+                        tx = env.beginTransaction(((TransactionBDBImpl) parent
+                                .getStorageTransaction()).getBDBTransaction(),
+                                tconfig);
                     else
                         tx = env.beginTransaction(null, tconfig);
                     return new TransactionBDBImpl(tx, env);
-                }
-                catch (DatabaseException ex)
-                {
-//                  System.err.println("Failed to create transaction, will exit - temporary behavior to be removed at some point.");
+                } catch (DatabaseException ex) {
+                    // System.err.println("Failed to create transaction, will exit - temporary behavior to be removed at some point.");
                     ex.printStackTrace(System.err);
-//                  System.exit(-1);
-                    throw new HGException("Failed to create BerkeleyDB transaction object.", ex);
+                    // System.exit(-1);
+                    throw new HGException(
+                            "Failed to create BerkeleyDB transaction object.",
+                            ex);
                 }
             }
         };
     }
 
-    public void removeData(HGPersistentHandle handle)
-    {
+    public void removeData(HGPersistentHandle handle) {
         if (handle == null)
-            throw new NullPointerException("HGStore.remove called with a null handle.");
-        try
-        {
+            throw new NullPointerException(
+                    "HGStore.remove called with a null handle.");
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             primitive_db.delete(txn().getBDBTransaction(), key);
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to remove value with handle " + handle + 
-                    ": " + ex.toString(), ex);            
+        } catch (Exception ex) {
+            throw new HGException("Failed to remove value with handle "
+                    + handle + ": " + ex.toString(), ex);
         }
     }
 
-    public void removeIncidenceLink(HGPersistentHandle handle, HGPersistentHandle oldLink)
-    {
+    public void removeIncidenceLink(HGPersistentHandle handle,
+            HGPersistentHandle oldLink) {
         Cursor cursor = null;
-        try
-        {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             DatabaseEntry value = new DatabaseEntry(oldLink.toByteArray());
-            cursor = incidence_db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchBoth(key, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            {
+            cursor = incidence_db.openCursor(txn().getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchBoth(key, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS) {
                 cursor.delete();
             }
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to update incidence set for handle " + handle + 
-                                  ": " + ex.toString(), ex);
-        }
-        finally
-        {
+        } catch (Exception ex) {
+            throw new HGException("Failed to update incidence set for handle "
+                    + handle + ": " + ex.toString(), ex);
+        } finally {
             if (cursor != null)
-                try { cursor.close(); } catch (Exception ex) { }
-        }  
+                try {
+                    cursor.close();
+                } catch (Exception ex) {
+                }
+        }
     }
 
-    public void removeIncidenceSet(HGPersistentHandle handle)
-    {
-        try
-        {
+    public void removeIncidenceSet(HGPersistentHandle handle) {
+        try {
             DatabaseEntry key = new DatabaseEntry(handle.toByteArray());
             incidence_db.delete(txn().getBDBTransaction(), key);
+        } catch (Exception ex) {
+            throw new HGException("Failed to remove incidence set of handle "
+                    + handle + ": " + ex.toString(), ex);
         }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to remove incidence set of handle " + handle + 
-                    ": " + ex.toString(), ex);            
-        }        
     }
 
     // ------------------------------------------------------------------------
     // INDEXING
     // ------------------------------------------------------------------------
-    
-    boolean checkIndexExisting(String name)
-    {
+
+    boolean checkIndexExisting(String name) {
         if (openIndices.get(name) != null)
             return true;
-        else
-        {
+        else {
             DatabaseConfig cfg = new DatabaseConfig();
             cfg.setAllowCreate(false);
             Database db = null;
-            try
-            {
-                db = env.openDatabase(null, DefaultIndexImpl.DB_NAME_PREFIX + name, null, cfg);
-            }
-            catch (Exception ex)
-            {
+            try {
+                db = env.openDatabase(null, DefaultIndexImpl.DB_NAME_PREFIX
+                        + name, cfg);
+            } catch (Exception ex) {
             }
-            if (db != null)             
-            {
-                try { db.close(); } catch (Throwable t) { t.printStackTrace(); }
+            if (db != null) {
+                try {
+                    db.close();
+                } catch (Throwable t) {
+                    t.printStackTrace();
+                }
                 return true;
-            }
-            else
+            } else
                 return false;
-        }       
-    }    
-    
+        }
+    }
+
     @SuppressWarnings("unchecked")
     public <KeyType, ValueType> HGIndex<KeyType, ValueType> getIndex(
             String name, ByteArrayConverter<KeyType> keyConverter,
             ByteArrayConverter<ValueType> valueConverter,
-            Comparator<?> comparator, 
-            boolean isBidirectional,
-            boolean createIfNecessary)
-    {
+            Comparator<?> comparator, boolean isBidirectional,
+            boolean createIfNecessary) {
         indicesLock.readLock().lock();
-        try
-        {
-            HGIndex<KeyType, ValueType> idx = (HGIndex<KeyType, ValueType>)openIndices.get(name);
+        try {
+            HGIndex<KeyType, ValueType> idx = (HGIndex<KeyType, ValueType>) openIndices
+                    .get(name);
             if (idx != null)
                 return idx;
             if (!checkIndexExisting(name) && !createIfNecessary)
                 return null;
+        } finally {
+            indicesLock.readLock().unlock();
         }
-        finally {indicesLock.readLock().unlock(); }
-        
+
         indicesLock.writeLock().lock();
-        try
-        {
-            HGIndex<KeyType, ValueType> idx = (HGIndex<KeyType, ValueType>)openIndices.get(name);
+        try {
+            HGIndex<KeyType, ValueType> idx = (HGIndex<KeyType, ValueType>) openIndices
+                    .get(name);
             if (idx != null)
                 return idx;
             if (!checkIndexExisting(name) && !createIfNecessary)
                 return null;
-            
+
             DefaultIndexImpl<KeyType, ValueType> result = null;
-            
+
             if (isBidirectional)
-                result =  new DefaultBiIndexImpl<KeyType, ValueType>(name, 
-                                                                     this, 
-                                                                     store.getTransactionManager(),
-                                                                     keyConverter, 
-                                                                     valueConverter,
-                                                                     comparator);
+                result = new DefaultBiIndexImpl<KeyType, ValueType>(name, this,
+                        store.getTransactionManager(), keyConverter,
+                        valueConverter, comparator);
             else
-                result = new DefaultIndexImpl<KeyType, ValueType>(name, 
-                                                                  this, 
-                                                                  store.getTransactionManager(),
-                                                                  keyConverter, 
-                                                                  valueConverter,
-                                                                  comparator);
-            result.open();          
+                result = new DefaultIndexImpl<KeyType, ValueType>(name, this,
+                        store.getTransactionManager(), keyConverter,
+                        valueConverter, comparator);
+            result.open();
             openIndices.put(name, result);
             return result;
-        }
-        finally
-        {
+        } finally {
             indicesLock.writeLock().unlock();
         }
     }
 
-    
     @SuppressWarnings("unchecked")
-    public void removeIndex(String name)
-    {
+    public void removeIndex(String name) {
         indicesLock.writeLock().lock();
-        try
-        {
+        try {
             HGIndex idx = openIndices.get(name);
-            if (idx != null)
-            {
+            if (idx != null) {
                 idx.close();
                 openIndices.remove(name);
             }
-            try
-            {
-                env.removeDatabase(null, DefaultIndexImpl.DB_NAME_PREFIX + name, null);
-            }
-            catch (Exception e)
-            {
+            try {
+                env.removeDatabase(null, DefaultIndexImpl.DB_NAME_PREFIX + name);
+            } catch (Exception e) {
                 throw new HGException(e);
             }
-        }
-        finally
-        {
+        } finally {
             indicesLock.writeLock().unlock();
-        }    
+        }
     }
 
     CheckPointThread checkPointThread = null;
-    
-    class CheckPointThread extends Thread 
-    {
+
+    class CheckPointThread extends Thread {
         boolean stop = false;
         boolean running = false;
-        
-        CheckPointThread()
-        {
+
+        CheckPointThread() {
             this.setName("HGCHECKPOINT");
-            this.setDaemon(true);                   
+            this.setDaemon(true);
         }
-        
-        public void run()
-        {
-            try
-            {
+
+        public void run() {
+            try {
                 running = true;
-                while (!stop)
-                {
+                while (!stop) {
                     Thread.sleep(60000);
                     if (!stop)
-                        try { env.checkpoint(null); }
-                        catch (DatabaseException ex) { throw new Error(ex); }
+                        try {
+                            env.checkpoint(null);
+                        } catch (DatabaseException ex) {
+                            throw new Error(ex);
+                        }
                 }
-            }
-            catch (InterruptedException ex)
-            {
+            } catch (InterruptedException ex) {
                 if (stop)
-                    try { env.checkpoint(null); }
-                    catch (DatabaseException dx) { throw new Error(dx); }                   
-            }
-            catch (Throwable t)
-            {               
-                System.err.println("HGDB CHECKPOINT THREAD exiting with: " + t.toString() + ", stack trace follows...");
+                    try {
+                        env.checkpoint(null);
+                    } catch (DatabaseException dx) {
+                        throw new Error(dx);
+                    }
+            } catch (Throwable t) {
+                System.err.println("HGDB CHECKPOINT THREAD exiting with: "
+                        + t.toString() + ", stack trace follows...");
                 t.printStackTrace(System.err);
-            }
-            finally
-            {
+            } finally {
                 running = false;
             }
         }
-    }    
+    }
 }
diff --git a/src/java/org/hypergraphdb/storage/ByteArrayConverter.java b/src/java/org/hypergraphdb/storage/ByteArrayConverter.java
index e7e5a00..cd5fb49 100644
--- a/src/java/org/hypergraphdb/storage/ByteArrayConverter.java
+++ b/src/java/org/hypergraphdb/storage/ByteArrayConverter.java
@@ -5,18 +5,18 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-/**
- * <p>
- * A utility interface to define mappings between <code>byte [] </code>
- * and object instances.
- * </p>
- * 
- * @author Borislav Iordanov
- */
-public interface ByteArrayConverter<T>
-{
-    byte [] toByteArray(T object);
-    T fromByteArray(byte [] byteArray);
-}
+package org.hypergraphdb.storage;
+
+/**
+ * <p>
+ * A utility interface to define mappings between <code>byte [] </code> and
+ * object instances.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public interface ByteArrayConverter<T> {
+    byte[] toByteArray(T object);
+
+    T fromByteArray(byte[] byteArray);
+}
diff --git a/src/java/org/hypergraphdb/storage/DBKeyedSortedSet.java b/src/java/org/hypergraphdb/storage/DBKeyedSortedSet.java
index feabbf4..44e6426 100644
--- a/src/java/org/hypergraphdb/storage/DBKeyedSortedSet.java
+++ b/src/java/org/hypergraphdb/storage/DBKeyedSortedSet.java
@@ -5,246 +5,197 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.SortedSet;
-
-import org.hypergraphdb.HGIndex;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.util.HGSortedSet;
-
-/**
- * 
- * <p>
- * A database-backed <code>HGSortedSet</code> implementation representing the 
- * ordered duplicate values associated with a single key.
- * </p>
- *
- * @author Borislav Iordanov
- *
- */
-@SuppressWarnings("unchecked")
-public class DBKeyedSortedSet<Key, T> implements HGSortedSet<T>
-{
-	private Key key;
-	private Comparator<T> comparator = null;
-	private HGIndex<Key, T> index = null;
-	
-	static <E> Comparator<E> makeComparator()
-	{
-		return new Comparator<E>()
-		{
-			public int compare(E x, E y)
-			{
-				return ((Comparable)x).compareTo(y);
-			}
-		};		
-	}
-	
-	public DBKeyedSortedSet(HGIndex<Key, T> idx, Key key)
-	{
-		this.index = idx;
-		this.key = key;
-		comparator = makeComparator();
-	}
-
-	public DBKeyedSortedSet(HGIndex<Key, T> idx, Key key, Comparator<T> comparator)
-	{
-		this.index = idx;
-		this.key = key;
-		this.comparator = comparator;		 
-	}
-	
-	
-	public HGRandomAccessResult<T> getSearchResult()
-	{
-		return index.find(key);
-	}
-
-	public Comparator<T> comparator()
-	{
-		return comparator;
-	}
-
-	public T first()
-	{
-		return index.findFirst(key);
-	}
-
-	public SortedSet<T> headSet(T toElement)
-	{
-		throw new UnsupportedOperationException();
-	}
-
-	public T last()
-	{
-		throw new UnsupportedOperationException("No easy BerkeleyDB method for this one, need to iterate until the end - unefficient.");
-	}
-
-	public SortedSet<T> subSet(T fromElement, T toElement)
-	{
-		throw new UnsupportedOperationException();	}
-
-	public SortedSet<T> tailSet(T fromElement)
-	{
-		throw new UnsupportedOperationException();	
-	}
-
-	public boolean add(T o)
-	{
-		if (contains(o))
-			return false;
-		index.addEntry(key, o);
-		return true;
-	}
-
-	public boolean addAll(Collection c)
-	{
-		boolean modified = false;
-		for (T x : (Collection<T>)c)
-			modified = modified || add(x);
-		return modified;
-	}
-
-	public void clear()
-	{
-		index.removeAllEntries(key);
-	}
-
-	public boolean contains(Object o)
-	{
-		HGRandomAccessResult<T> rs = getSearchResult();
-		try 
-		{ 
-			return rs.goTo((T)o, true) == HGRandomAccessResult.GotoResult.found; 
-		}
-		finally
-		{
-			rs.close();
-		}
-	}
-
-	public boolean containsAll(Collection c)
-	{
-		HGRandomAccessResult<T> rs = getSearchResult();
-		try 
-		{ 
-			for (T x : (Collection<T>)c)			
-				if (rs.goTo(x, true) != HGRandomAccessResult.GotoResult.found)
-					return false;
-			return true;
-		}
-		finally
-		{
-			rs.close();
-		}
-	}
-
-	public boolean isEmpty()
-	{
-		return first() == null;
-	}
-
-	/**
-	 * <p>
-	 * This iterator is intended for use when full iteration is performed on the set. 
-	 * Otherwise, the underlying DB cursor remains open and locks DB pages forever.
-	 * </p>
-	 */
-	public Iterator<T> iterator()
-	{
-/*		final HGRandomAccessResult<T> rs = getSearchResult();
-		return new Iterator<T>()
-		{
-			boolean closed = false;
-			public void remove() { throw new UnsupportedOperationException(); }
-			public boolean hasNext() 
-			{
-				return !closed && rs.hasNext();
-			}
-			public T next()
-			{
-				T n = rs.next();
-				if (!rs.hasNext())
-				{
-					rs.close();
-					closed = true;
-				}
-				return n;
-			}
-			
-			protected void finalize() { if (!closed) rs.close(); } 
-		}; */
-		throw new UnsupportedOperationException("Use getSearchResult and make sure you close it.");
-	}
-
-	public boolean remove(Object o)
-	{
-		if (contains(o))
-		{
-			index.removeEntry(key, (T)o);
-			return true;
-		}
-		else
-			return false;
-	}
-
-	public boolean removeAll(Collection c)
-	{
-		boolean modified = false;
-		for (Object x : c)
-			modified = modified || remove(x);
-		return modified;
-	}
-
-	public boolean retainAll(Collection c)
-	{
-		throw new UnsupportedOperationException();
-	}
-
-	public int size()
-	{
-		return (int)index.count(key);
-	}
-
-	public Object[] toArray()
-	{
-		HGRandomAccessResult<T> rs = getSearchResult();
-		try
-		{
-			int size = size();
-	        Object [] a = new Object[size];
-	        for (int i = 0; i < size; i++)
-	        	a[i] = rs.next();
-	        return a;
-		}
-		finally
-		{
-			rs.close();
-		}
-	}
-
-	public <E> E[] toArray(E[] a)
-	{
-		HGRandomAccessResult<T> rs = getSearchResult();
-		try
-		{
-	        int size = size();
-	        if (a.length < size)
-	            a = (E[])java.lang.reflect.Array
-			.newInstance(a.getClass().getComponentType(), size);
-	        for (int i = 0; i < size; i++)
-	        	a[i] = (E)rs.next();
-	        if (a.length > size)
-	        	a[size] = null;
-	        return a;
-		}
-		finally
-		{
-			rs.close();
-		}
-	}
-}
+package org.hypergraphdb.storage;
+
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.SortedSet;
+
+import org.hypergraphdb.HGIndex;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.util.HGSortedSet;
+
+/**
+ * 
+ * <p>
+ * A database-backed <code>HGSortedSet</code> implementation representing the
+ * ordered duplicate values associated with a single key.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ * 
+ */
+@SuppressWarnings("unchecked")
+public class DBKeyedSortedSet<Key, T> implements HGSortedSet<T> {
+    private Key key;
+    private Comparator<T> comparator = null;
+    private HGIndex<Key, T> index = null;
+
+    static <E> Comparator<E> makeComparator() {
+        return new Comparator<E>() {
+            public int compare(E x, E y) {
+                return ((Comparable) x).compareTo(y);
+            }
+        };
+    }
+
+    public DBKeyedSortedSet(HGIndex<Key, T> idx, Key key) {
+        this.index = idx;
+        this.key = key;
+        comparator = makeComparator();
+    }
+
+    public DBKeyedSortedSet(HGIndex<Key, T> idx, Key key,
+            Comparator<T> comparator) {
+        this.index = idx;
+        this.key = key;
+        this.comparator = comparator;
+    }
+
+    public HGRandomAccessResult<T> getSearchResult() {
+        return index.find(key);
+    }
+
+    public Comparator<T> comparator() {
+        return comparator;
+    }
+
+    public T first() {
+        return index.findFirst(key);
+    }
+
+    public SortedSet<T> headSet(T toElement) {
+        throw new UnsupportedOperationException();
+    }
+
+    public T last() {
+        throw new UnsupportedOperationException(
+                "No easy BerkeleyDB method for this one, need to iterate until the end - unefficient.");
+    }
+
+    public SortedSet<T> subSet(T fromElement, T toElement) {
+        throw new UnsupportedOperationException();
+    }
+
+    public SortedSet<T> tailSet(T fromElement) {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean add(T o) {
+        if (contains(o))
+            return false;
+        index.addEntry(key, o);
+        return true;
+    }
+
+    public boolean addAll(Collection c) {
+        boolean modified = false;
+        for (T x : (Collection<T>) c)
+            modified = modified || add(x);
+        return modified;
+    }
+
+    public void clear() {
+        index.removeAllEntries(key);
+    }
+
+    public boolean contains(Object o) {
+        HGRandomAccessResult<T> rs = getSearchResult();
+        try {
+            return rs.goTo((T) o, true) == HGRandomAccessResult.GotoResult.found;
+        } finally {
+            rs.close();
+        }
+    }
+
+    public boolean containsAll(Collection c) {
+        HGRandomAccessResult<T> rs = getSearchResult();
+        try {
+            for (T x : (Collection<T>) c)
+                if (rs.goTo(x, true) != HGRandomAccessResult.GotoResult.found)
+                    return false;
+            return true;
+        } finally {
+            rs.close();
+        }
+    }
+
+    public boolean isEmpty() {
+        return first() == null;
+    }
+
+    /**
+     * <p>
+     * This iterator is intended for use when full iteration is performed on the
+     * set. Otherwise, the underlying DB cursor remains open and locks DB pages
+     * forever.
+     * </p>
+     */
+    public Iterator<T> iterator() {
+        /*
+         * final HGRandomAccessResult<T> rs = getSearchResult(); return new
+         * Iterator<T>() { boolean closed = false; public void remove() { throw
+         * new UnsupportedOperationException(); } public boolean hasNext() {
+         * return !closed && rs.hasNext(); } public T next() { T n = rs.next();
+         * if (!rs.hasNext()) { rs.close(); closed = true; } return n; }
+         * 
+         * protected void finalize() { if (!closed) rs.close(); } };
+         */
+        throw new UnsupportedOperationException(
+                "Use getSearchResult and make sure you close it.");
+    }
+
+    public boolean remove(Object o) {
+        if (contains(o)) {
+            index.removeEntry(key, (T) o);
+            return true;
+        } else
+            return false;
+    }
+
+    public boolean removeAll(Collection c) {
+        boolean modified = false;
+        for (Object x : c)
+            modified = modified || remove(x);
+        return modified;
+    }
+
+    public boolean retainAll(Collection c) {
+        throw new UnsupportedOperationException();
+    }
+
+    public int size() {
+        return (int) index.count(key);
+    }
+
+    public Object[] toArray() {
+        HGRandomAccessResult<T> rs = getSearchResult();
+        try {
+            int size = size();
+            Object[] a = new Object[size];
+            for (int i = 0; i < size; i++)
+                a[i] = rs.next();
+            return a;
+        } finally {
+            rs.close();
+        }
+    }
+
+    public <E> E[] toArray(E[] a) {
+        HGRandomAccessResult<T> rs = getSearchResult();
+        try {
+            int size = size();
+            if (a.length < size)
+                a = (E[]) java.lang.reflect.Array.newInstance(a.getClass()
+                        .getComponentType(), size);
+            for (int i = 0; i < size; i++)
+                a[i] = (E) rs.next();
+            if (a.length > size)
+                a[size] = null;
+            return a;
+        } finally {
+            rs.close();
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/DefaultBiIndexImpl.java b/src/java/org/hypergraphdb/storage/DefaultBiIndexImpl.java
index 37bccd6..5a3048f 100644
--- a/src/java/org/hypergraphdb/storage/DefaultBiIndexImpl.java
+++ b/src/java/org/hypergraphdb/storage/DefaultBiIndexImpl.java
@@ -5,223 +5,212 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
+package org.hypergraphdb.storage;
+
 import java.util.Comparator;
-
-
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.SecondaryCursor;
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-import com.sleepycat.db.SecondaryConfig;
-import com.sleepycat.db.SecondaryDatabase;
-
-import org.hypergraphdb.HGBidirectionalIndex;
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.HGSearchResult;
-import org.hypergraphdb.transaction.HGTransactionManager;
-import org.hypergraphdb.transaction.TransactionBDBImpl;
-
-@SuppressWarnings("unchecked")
-public class DefaultBiIndexImpl<KeyType, ValueType> 
-	extends DefaultIndexImpl<KeyType, ValueType> implements HGBidirectionalIndex<KeyType, ValueType>
-{
-    private static final String SECONDARY_DB_NAME_PREFIX = DB_NAME_PREFIX + "_secondary";
-    
-    private DatabaseEntry dummy = new DatabaseEntry();
-    private SecondaryDatabase secondaryDb = null;
-    
-    public DefaultBiIndexImpl(String indexName, 
-                              BDBStorageImplementation storage, 
-    						  HGTransactionManager transactionManager,
-    						  ByteArrayConverter<KeyType> keyConverter,
-    						  ByteArrayConverter<ValueType> valueConverter,
-    						  Comparator<?> comparator)
-    {
-        super(indexName, storage, transactionManager, keyConverter, valueConverter, comparator);
-    }
-    
-    public void open()
-    {
-    	sort_duplicates = false;
-        super.open();
-        try
-        {
-            SecondaryConfig dbConfig = new SecondaryConfig();
+
+import org.hypergraphdb.HGBidirectionalIndex;
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.HGSearchResult;
+import org.hypergraphdb.transaction.HGTransactionManager;
+import org.hypergraphdb.transaction.TransactionBDBImpl;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+import com.sleepycat.je.SecondaryConfig;
+import com.sleepycat.je.SecondaryCursor;
+import com.sleepycat.je.SecondaryDatabase;
+
+@SuppressWarnings("unchecked")
+public class DefaultBiIndexImpl<KeyType, ValueType> extends
+        DefaultIndexImpl<KeyType, ValueType> implements
+        HGBidirectionalIndex<KeyType, ValueType> {
+    private static final String SECONDARY_DB_NAME_PREFIX = DB_NAME_PREFIX
+            + "_secondary";
+
+    private DatabaseEntry dummy = new DatabaseEntry();
+    private SecondaryDatabase secondaryDb = null;
+
+    public DefaultBiIndexImpl(String indexName,
+            BDBStorageImplementation storage,
+            HGTransactionManager transactionManager,
+            ByteArrayConverter<KeyType> keyConverter,
+            ByteArrayConverter<ValueType> valueConverter,
+            Comparator<?> comparator) {
+        super(indexName, storage, transactionManager, keyConverter,
+                valueConverter, comparator);
+    }
+
+    public void open() {
+        sort_duplicates = false;
+        super.open();
+        try {
+            SecondaryConfig dbConfig = new SecondaryConfig();
             dbConfig.setAllowCreate(true);
-            if (storage.getBerkleyEnvironment().getConfig().getTransactional())
-            {
-                dbConfig.setTransactional(true);                
-                if (storage.getConfiguration().isStorageMVCC())                    
-                    dbConfig.setMultiversion(true);
-            }
-            dbConfig.setKeyCreator(PlainSecondaryKeyCreator.getInstance());
-            dbConfig.setSortedDuplicates(true);
-            dbConfig.setType(storage.getConfiguration().getDatabaseConfig().getType());    
-            secondaryDb = storage.getBerkleyEnvironment().openSecondaryDatabase(null, SECONDARY_DB_NAME_PREFIX + name, null, db, dbConfig);
-        }
-        catch (Throwable t)
-        {
-            throw new HGException("While attempting to open index ;" + 
-                                  name + "': " + t.toString(), t);
-        }
-    }
-
-    public void close()
-    {
-        HGException exception = null;
-        
-        try
-        {
-            super.close();
-        }
-        catch (HGException ex)
-        {
-            exception = ex;
-        }
-     
-        if (secondaryDb == null)
-        	return;
-        
-        // Attempt to close secondary database even if there was an exception
-        // during the close of the primary.
-        try
-        {
-            secondaryDb.close();
-        }
-        catch(Throwable t)
-        {
-            if (exception == null)
-                exception = new HGException(t);
-        }
-        finally
-        {
-            secondaryDb = null;            
-        }
-        
-        if (exception != null)
-            throw exception;
-    }
-    
-    public boolean isOpen()
-    {
-        return super.isOpen() && secondaryDb != null;
-    }
-    
-    public void addEntry(KeyType key, ValueType value)
-    {
-        checkOpen();
-        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry dbvalue = new DatabaseEntry(valueConverter.toByteArray(value)); 
-        try
-        {
-            OperationStatus result = db.put(txn().getBDBTransaction(), dbkey, dbvalue);
-            if (result != OperationStatus.SUCCESS && result != OperationStatus.KEYEXIST)
-                throw new Exception("OperationStatus: " + result);            
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to add entry to index '" + 
-                                  name + "': " + ex.toString(), ex);
-        }
-    }
-    
-    public HGRandomAccessResult<KeyType> findByValue(ValueType value)
-    {
-        if (!isOpen())
-            throw new HGException("Attempting to lookup index '" + 
-                                  name + 
-                                  "' while it is closed.");      
-/*        if (value == null)
-            throw new HGException("Attempting to lookup index '" + 
-                                  name + "' with a null key."); */
-        DatabaseEntry keyEntry = new DatabaseEntry(valueConverter.toByteArray(value));
-        DatabaseEntry valueEntry = new DatabaseEntry();        
-        HGRandomAccessResult<KeyType> result = null;
-        SecondaryCursor cursor = null;
-        try
-        {
-        	TransactionBDBImpl tx = txn();
-            cursor = secondaryDb.openSecondaryCursor(tx.getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry, dummy, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
-                result = new SingleValueResultSet<KeyType>(tx.attachCursor(cursor), keyEntry, keyConverter);
-            else 
-            {
-                try { cursor.close(); } catch (Throwable t) { }
-                result = (HGRandomAccessResult<KeyType>)HGSearchResult.EMPTY;
-            }
-        }
-        catch (Exception ex)
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }            
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        return result;
-    }
-
-    public KeyType findFirstByValue(ValueType value)
-    {
-        if (!isOpen())
-            throw new HGException("Attempting to lookup by value index '" + 
-                                  name + 
-                                  "' while it is closed.");
-/*        if (value == null)
-            throw new HGException("Attempting to lookup by value index '" + 
-                                  name + "' with a null value."); */
-        DatabaseEntry keyEntry = new DatabaseEntry(valueConverter.toByteArray(value));
-        DatabaseEntry valueEntry = new DatabaseEntry();        
-        KeyType result = null;
-        SecondaryCursor cursor = null;
-        try
-        {        	
-            cursor = secondaryDb.openSecondaryCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry, dummy, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                result = keyConverter.fromByteArray(valueEntry.getData());
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        finally
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        }
-        return result;
-    }
-
-	public long countKeys(ValueType value)
-	{
-        DatabaseEntry keyEntry = new DatabaseEntry(valueConverter.toByteArray(value));
-        DatabaseEntry valueEntry = new DatabaseEntry();        
-        SecondaryCursor cursor = null;
-        try
-        {
-            cursor = secondaryDb.openSecondaryCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry, dummy, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            	return cursor.count();
-            else 
-            	return 0;
-        }
-        catch (DatabaseException ex)
-        {
-        	throw new HGException(ex);
-        }
-        finally
-        {
-        	if (cursor != null)        
-        		try { cursor.close(); } catch (Throwable t) { }
-        }
-	}    
-}
+            if (storage.getBerkleyEnvironment().getConfig().getTransactional()) {
+                dbConfig.setTransactional(true);
+
+            }
+            dbConfig.setKeyCreator(PlainSecondaryKeyCreator.getInstance());
+            dbConfig.setSortedDuplicates(true);
+            secondaryDb = storage.getBerkleyEnvironment()
+                    .openSecondaryDatabase(null,
+                            SECONDARY_DB_NAME_PREFIX + name, db, dbConfig);
+        } catch (Throwable t) {
+            throw new HGException("While attempting to open index ;" + name
+                    + "': " + t.toString(), t);
+        }
+    }
+
+    public void close() {
+        HGException exception = null;
+
+        try {
+            super.close();
+        } catch (HGException ex) {
+            exception = ex;
+        }
+
+        if (secondaryDb == null)
+            return;
+
+        // Attempt to close secondary database even if there was an exception
+        // during the close of the primary.
+        try {
+            secondaryDb.close();
+        } catch (Throwable t) {
+            if (exception == null)
+                exception = new HGException(t);
+        } finally {
+            secondaryDb = null;
+        }
+
+        if (exception != null)
+            throw exception;
+    }
+
+    public boolean isOpen() {
+        return super.isOpen() && secondaryDb != null;
+    }
+
+    public void addEntry(KeyType key, ValueType value) {
+        checkOpen();
+        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
+        DatabaseEntry dbvalue = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        try {
+            OperationStatus result = db.put(txn().getBDBTransaction(), dbkey,
+                    dbvalue);
+            if (result != OperationStatus.SUCCESS
+                    && result != OperationStatus.KEYEXIST)
+                throw new Exception("OperationStatus: " + result);
+        } catch (Exception ex) {
+            throw new HGException("Failed to add entry to index '" + name
+                    + "': " + ex.toString(), ex);
+        }
+    }
+
+    public HGRandomAccessResult<KeyType> findByValue(ValueType value) {
+        if (!isOpen())
+            throw new HGException("Attempting to lookup index '" + name
+                    + "' while it is closed.");
+        /*
+         * if (value == null) throw new
+         * HGException("Attempting to lookup index '" + name +
+         * "' with a null key.");
+         */
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        DatabaseEntry valueEntry = new DatabaseEntry();
+        HGRandomAccessResult<KeyType> result = null;
+        SecondaryCursor cursor = null;
+        try {
+            TransactionBDBImpl tx = txn();
+            cursor = secondaryDb.openSecondaryCursor(tx.getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry,
+                    dummy, LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
+                result = new SingleValueResultSet<KeyType>(
+                        tx.attachCursor(cursor), keyEntry, keyConverter);
+            else {
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+                result = (HGRandomAccessResult<KeyType>) HGSearchResult.EMPTY;
+            }
+        } catch (Exception ex) {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        }
+        return result;
+    }
+
+    public KeyType findFirstByValue(ValueType value) {
+        if (!isOpen())
+            throw new HGException("Attempting to lookup by value index '"
+                    + name + "' while it is closed.");
+        /*
+         * if (value == null) throw new
+         * HGException("Attempting to lookup by value index '" + name +
+         * "' with a null value.");
+         */
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        DatabaseEntry valueEntry = new DatabaseEntry();
+        KeyType result = null;
+        SecondaryCursor cursor = null;
+        try {
+            cursor = secondaryDb.openSecondaryCursor(txn().getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry,
+                    dummy, LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                result = keyConverter.fromByteArray(valueEntry.getData());
+        } catch (Exception ex) {
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+        return result;
+    }
+
+    public long countKeys(ValueType value) {
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        DatabaseEntry valueEntry = new DatabaseEntry();
+        SecondaryCursor cursor = null;
+        try {
+            cursor = secondaryDb.openSecondaryCursor(txn().getBDBTransaction(),
+                    cursorConfig);
+            OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry,
+                    dummy, LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return cursor.count();
+            else
+                return 0;
+        } catch (DatabaseException ex) {
+            throw new HGException(ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/DefaultIndexImpl.java b/src/java/org/hypergraphdb/storage/DefaultIndexImpl.java
index 4f82498..9463b77 100644
--- a/src/java/org/hypergraphdb/storage/DefaultIndexImpl.java
+++ b/src/java/org/hypergraphdb/storage/DefaultIndexImpl.java
@@ -5,535 +5,508 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.Comparator;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.HGSearchResult;
-import org.hypergraphdb.HGSortIndex;
-import org.hypergraphdb.transaction.HGTransaction;
-import org.hypergraphdb.transaction.HGTransactionManager;
-import org.hypergraphdb.transaction.TransactionBDBImpl;
-import org.hypergraphdb.transaction.VanillaTransaction;
-
-import com.sleepycat.db.BtreeStats;
-import com.sleepycat.db.CursorConfig;
-import com.sleepycat.db.Database;
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.DatabaseType;
-import com.sleepycat.db.Cursor;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.DatabaseConfig;
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.OperationStatus;
-import com.sleepycat.db.Transaction;
-
-/**
- * <p>
- * A default index implementation. This implementation works by maintaining
- * a separate DB, using a B-tree, <code>byte []</code> lexicographical ordering
- * on its keys. The keys are therefore assumed to by <code>byte [] </code>
- * instances.
- * </p>
- * 
- * @author Borislav Iordanov
- */
-@SuppressWarnings("unchecked")
-public class DefaultIndexImpl<KeyType, ValueType> implements HGSortIndex<KeyType, ValueType>
-{
-	/**
-	 * Prefix of HyperGraph index DB filenames.
-	 */
-    public static final String DB_NAME_PREFIX = "hgstore_idx_";
-        
+package org.hypergraphdb.storage;
+
+import java.util.Comparator;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.HGSearchResult;
+import org.hypergraphdb.HGSortIndex;
+import org.hypergraphdb.transaction.HGTransaction;
+import org.hypergraphdb.transaction.HGTransactionManager;
+import org.hypergraphdb.transaction.TransactionBDBImpl;
+import org.hypergraphdb.transaction.VanillaTransaction;
+
+import com.sleepycat.je.BtreeStats;
+import com.sleepycat.je.Cursor;
+import com.sleepycat.je.CursorConfig;
+import com.sleepycat.je.Database;
+import com.sleepycat.je.DatabaseConfig;
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+import com.sleepycat.je.StatsConfig;
+import com.sleepycat.je.Transaction;
+
+/**
+ * <p>
+ * A default index implementation. This implementation works by maintaining a
+ * separate DB, using a B-tree, <code>byte []</code> lexicographical ordering on
+ * its keys. The keys are therefore assumed to by <code>byte [] </code>
+ * instances.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+@SuppressWarnings("unchecked")
+public class DefaultIndexImpl<KeyType, ValueType> implements
+        HGSortIndex<KeyType, ValueType> {
+    /**
+     * Prefix of HyperGraph index DB filenames.
+     */
+    public static final String DB_NAME_PREFIX = "hgstore_idx_";
+
     protected BDBStorageImplementation storage;
-    protected CursorConfig cursorConfig = new CursorConfig();
-    protected HGTransactionManager transactionManager;
-    protected String name;
-    protected Database db;
-    private   boolean owndb;
-    protected Comparator comparator;
-    protected boolean sort_duplicates = true;
-    protected ByteArrayConverter<KeyType> keyConverter;
-    protected ByteArrayConverter<ValueType> valueConverter;
-    
-    protected void checkOpen()
-    {
-        if (!isOpen())
-            throw new HGException("Attempting to operate on index '" + 
-                                  name + 
-                                  "' while the index is being closed.");              
-    }
-
-    protected TransactionBDBImpl txn()
-    {
-    	HGTransaction tx = transactionManager.getContext().getCurrent();
-    	if (tx == null || tx.getStorageTransaction() instanceof VanillaTransaction)
-    		return TransactionBDBImpl.nullTransaction();
-    	else
-    		return (TransactionBDBImpl)tx.getStorageTransaction();
-    }
-
-//    public DefaultIndexImpl(Environment env,
-//    						Database db,
-//							HGTransactionManager transactionManager,
-//							ByteArrayConverter<KeyType> keyConverter,
-//							ByteArrayConverter<ValueType> valueConverter,
-//							Comparator comparator)
-//	{
-//		this.db = db;
-//		this.env = env;
-//		this.transactionManager = transactionManager;
-//		this.keyConverter = keyConverter;
-//		this.valueConverter = valueConverter;
-//		this.comparator = comparator;
-//		owndb = false;
-//		try { name = db.getDatabaseName(); }
-//		catch (Exception ex) { throw new HGException(ex); }
-//		
-//	}
-    
-    public DefaultIndexImpl(String indexName, 
-    						BDBStorageImplementation storage,
-    						HGTransactionManager transactionManager,
-    						ByteArrayConverter<KeyType> keyConverter,
-    						ByteArrayConverter<ValueType> valueConverter,
-    						Comparator comparator)
-    {
+    protected CursorConfig cursorConfig = new CursorConfig();
+    protected HGTransactionManager transactionManager;
+    protected String name;
+    protected Database db;
+    private boolean owndb;
+    protected Comparator comparator;
+    protected boolean sort_duplicates = true;
+    protected ByteArrayConverter<KeyType> keyConverter;
+    protected ByteArrayConverter<ValueType> valueConverter;
+
+    protected void checkOpen() {
+        if (!isOpen())
+            throw new HGException("Attempting to operate on index '" + name
+                    + "' while the index is being closed.");
+    }
+
+    protected TransactionBDBImpl txn() {
+        HGTransaction tx = transactionManager.getContext().getCurrent();
+        if (tx == null
+                || tx.getStorageTransaction() instanceof VanillaTransaction)
+            return TransactionBDBImpl.nullTransaction();
+        else
+            return (TransactionBDBImpl) tx.getStorageTransaction();
+    }
+
+    // public DefaultIndexImpl(Environment env,
+    // Database db,
+    // HGTransactionManager transactionManager,
+    // ByteArrayConverter<KeyType> keyConverter,
+    // ByteArrayConverter<ValueType> valueConverter,
+    // Comparator comparator)
+    // {
+    // this.db = db;
+    // this.env = env;
+    // this.transactionManager = transactionManager;
+    // this.keyConverter = keyConverter;
+    // this.valueConverter = valueConverter;
+    // this.comparator = comparator;
+    // owndb = false;
+    // try { name = db.getDatabaseName(); }
+    // catch (Exception ex) { throw new HGException(ex); }
+    //
+    // }
+
+    public DefaultIndexImpl(String indexName, BDBStorageImplementation storage,
+            HGTransactionManager transactionManager,
+            ByteArrayConverter<KeyType> keyConverter,
+            ByteArrayConverter<ValueType> valueConverter, Comparator comparator) {
         this.name = indexName;
-        this.storage = storage;
-        this.transactionManager = transactionManager;
-        this.keyConverter = keyConverter;
-        this.valueConverter = valueConverter;
-        this.comparator = comparator;
-        owndb = true;
-    }
-    
-    public String getName()
-    {
-        return name;
-    }
-    
-    public String getDatabaseName()
-    {
-        return DB_NAME_PREFIX + name;
-    }
-    
-    public Comparator getComparator()
-    {
-        try
-        {
+        this.storage = storage;
+        this.transactionManager = transactionManager;
+        this.keyConverter = keyConverter;
+        this.valueConverter = valueConverter;
+        this.comparator = comparator;
+        owndb = true;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getDatabaseName() {
+        return DB_NAME_PREFIX + name;
+    }
+
+    public Comparator getComparator() {
+        try {
             if (comparator != null)
                 return comparator;
-            else if (db.getConfig().getType() == DatabaseType.BTREE)
+            else
                 return db.getConfig().getBtreeComparator();
-            else 
-                return db.getConfig().getHashComparator();
-        }
-        catch (DatabaseException ex)
-        {
+        } catch (DatabaseException ex) {
             throw new HGException(ex);
-        }
-    }
-    
-    public void open()
-    {    	
-        try
-        {
-            DatabaseConfig dbConfig = storage.getConfiguration().getDatabaseConfig().cloneConfig();
-            if (storage.getBerkleyEnvironment().getConfig().getTransactional() &&
-                storage.getConfiguration().isStorageMVCC())
-                    cursorConfig.setSnapshot(true);
-            dbConfig.setSortedDuplicates(sort_duplicates);
-            if (comparator != null)
-            {
-                if (dbConfig.getType() == DatabaseType.BTREE)
-                    dbConfig.setBtreeComparator(comparator);
-                else
-                    dbConfig.setHashComparator(comparator);
+        }
+    }
+
+    public void open() {
+        try {
+            DatabaseConfig dbConfig = storage.getConfiguration()
+                    .getDatabaseConfig().clone();
+            if (storage.getBerkleyEnvironment().getConfig().getTransactional()
+                    && storage.getConfiguration().isStorageMVCC())
+                cursorConfig.setReadCommitted(true);
+            dbConfig.setSortedDuplicates(sort_duplicates);
+//            if (comparator != null) {
+//                dbConfig.setBtreeComparator(comparator);
+//            }
+            db = storage.getBerkleyEnvironment().openDatabase(null,
+                    DB_NAME_PREFIX + name, dbConfig);
+        } catch (Throwable t) {
+            throw new HGException("While attempting to open index ;" + name
+                    + "': " + t.toString(), t);
+        }
+    }
+
+    public void close() {
+        if (db == null || !owndb)
+            return;
+        try {
+            db.close();
+        } catch (Throwable t) {
+            throw new HGException(t);
+        } finally {
+            db = null;
+        }
+    }
+
+    public boolean isOpen() {
+        return db != null;
+    }
+
+    public HGRandomAccessResult<ValueType> scanValues() {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry();
+        DatabaseEntry value = new DatabaseEntry();
+        HGRandomAccessResult result = null;
+        Cursor cursor = null;
+        try {
+            TransactionBDBImpl tx = txn();
+            cursor = db.openCursor(tx.getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getFirst(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
+                result = new KeyRangeForwardResultSet(tx.attachCursor(cursor),
+                        keyEntry, valueConverter);
+            else {
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+                result = HGSearchResult.EMPTY;
+            }
+        } catch (Throwable ex) {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        }
+        return result;
+    }
+
+    public HGRandomAccessResult<KeyType> scanKeys() {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry();
+        DatabaseEntry value = new DatabaseEntry();
+        HGRandomAccessResult result = null;
+        Cursor cursor = null;
+        try {
+            TransactionBDBImpl tx = txn();
+            cursor = db.openCursor(tx.getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getFirst(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
+                result = new KeyScanResultSet(tx.attachCursor(cursor),
+                        keyEntry, keyConverter);
+            else {
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+                result = HGSearchResult.EMPTY;
             }
-            db = storage.getBerkleyEnvironment().openDatabase(null, DB_NAME_PREFIX + name, null, dbConfig);
-        }
-        catch (Throwable t)
-        {
-            throw new HGException("While attempting to open index ;" + 
-                                  name + "': " + t.toString(), t);
-        }
-    }
-
-    public void close()
-    {
-    	if (db == null || !owndb)
-    		return;
-        try
-        {
-            db.close();
-        }
-        catch(Throwable t)
-        {
-            throw new HGException(t);
-        }
-        finally
-        {
-            db = null;            
-        }
-    }
-    
-    public boolean isOpen()
-    {
-        return db != null;
-    }
-    
-    public HGRandomAccessResult<ValueType> scanValues()
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry();
-        DatabaseEntry value = new DatabaseEntry();        
-        HGRandomAccessResult result = null;
-        Cursor cursor = null;
-        try
-        {
-        	TransactionBDBImpl tx = txn();
-            cursor = db.openCursor(tx.getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getFirst(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
-                result = new KeyRangeForwardResultSet(tx.attachCursor(cursor), keyEntry, valueConverter);
-            else 
-            {
-                try { cursor.close(); } catch (Throwable t) { }
-                result = HGSearchResult.EMPTY;
-            }                
-        }
-        catch (Throwable ex)
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        	throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        return result;        
-    }
-
-    public HGRandomAccessResult<KeyType> scanKeys()
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry();
-        DatabaseEntry value = new DatabaseEntry();        
-        HGRandomAccessResult result = null;
-        Cursor cursor = null;       
-        try
-        {
-        	TransactionBDBImpl tx = txn();
-            cursor = db.openCursor(tx.getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getFirst(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
-                result = new KeyScanResultSet(tx.attachCursor(cursor), keyEntry, keyConverter);
-            else 
-            {
-                try { cursor.close(); } catch (Throwable t) { }
-                result = HGSearchResult.EMPTY;
-            }                
-        }
-        catch (Throwable ex)
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        	throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        return result;        
-    }
-    
-    public void addEntry(KeyType key, ValueType value)
-    {
-        checkOpen();
-        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry dbvalue = new DatabaseEntry(valueConverter.toByteArray(value)); 
-        try
-        {
-            OperationStatus result = db.putNoDupData(txn().getBDBTransaction(), dbkey, dbvalue);
-            if (result != OperationStatus.SUCCESS && result != OperationStatus.KEYEXIST)
-                throw new Exception("OperationStatus: " + result);            
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to add entry to index '" + 
-                                  name + "': " + ex.toString(), ex);
-        }
-    }
-
-    public void removeEntry(KeyType key, ValueType value)
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry valueEntry = new DatabaseEntry(valueConverter.toByteArray(value));
-        Cursor cursor = null;
-        try
-        {
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            if (cursor.getSearchBoth(keyEntry, valueEntry, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-                cursor.delete();
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        finally
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        }
-    }
-
-    public void removeAllEntries(KeyType key)
-    {
-        checkOpen();
-        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
-        try
-        {
-            db.delete(txn().getBDBTransaction(), dbkey);
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to delete entry from index '" + 
-                                  name + "': " + ex.toString(), ex);
-        }
-    }
-    
-    void ping(Transaction tx)
-    {
+        } catch (Throwable ex) {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        }
+        return result;
+    }
+
+    public void addEntry(KeyType key, ValueType value) {
+        checkOpen();
+        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
+        DatabaseEntry dbvalue = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        try {
+            OperationStatus result = db.putNoDupData(txn().getBDBTransaction(),
+                    dbkey, dbvalue);
+            if (result != OperationStatus.SUCCESS
+                    && result != OperationStatus.KEYEXIST)
+                throw new Exception("OperationStatus: " + result);
+        } catch (Exception ex) {
+            throw new HGException("Failed to add entry to index '" + name
+                    + "': " + ex.toString(), ex);
+        }
+    }
+
+    public void removeEntry(KeyType key, ValueType value) {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                keyConverter.toByteArray(key));
+        DatabaseEntry valueEntry = new DatabaseEntry(
+                valueConverter.toByteArray(value));
+        Cursor cursor = null;
+        try {
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            if (cursor.getSearchBoth(keyEntry, valueEntry, LockMode.DEFAULT) == OperationStatus.SUCCESS)
+                cursor.delete();
+        } catch (Exception ex) {
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+    }
+
+    public void removeAllEntries(KeyType key) {
+        checkOpen();
+        DatabaseEntry dbkey = new DatabaseEntry(keyConverter.toByteArray(key));
+        try {
+            db.delete(txn().getBDBTransaction(), dbkey);
+        } catch (Exception ex) {
+            throw new HGException("Failed to delete entry from index '" + name
+                    + "': " + ex.toString(), ex);
+        }
+    }
+
+    void ping(Transaction tx) {
         DatabaseEntry key = new DatabaseEntry(new byte[1]);
         DatabaseEntry data = new DatabaseEntry();
-        try
-        {
+        try {
             db.get(tx, key, data, LockMode.DEFAULT);
+        } catch (Exception ex) {
+            throw new HGException("Failed to ping index '" + name + "': "
+                    + ex.toString(), ex);
+        }
+    }
+
+    public ValueType findFirst(KeyType key) {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                keyConverter.toByteArray(key));
+        DatabaseEntry value = new DatabaseEntry();
+        ValueType result = null;
+        Cursor cursor = null;
+        try {
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getSearchKey(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                result = valueConverter.fromByteArray(value.getData());
+        } catch (Exception ex) {
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+        return result;
+    }
+
+    /**
+     * <p>
+     * Find the last entry, assuming ordered duplicates, corresponding to the
+     * given key.
+     * </p>
+     * 
+     * @param key
+     *            The key whose last entry is sought.
+     * @return The last (i.e. greatest, i.e. maximum) data value for that key or
+     *         null if the set of entries for the key is empty.
+     */
+    public ValueType findLast(KeyType key) {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                keyConverter.toByteArray(key));
+        DatabaseEntry value = new DatabaseEntry();
+        ValueType result = null;
+        Cursor cursor = null;
+        try {
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getLast(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                result = valueConverter.fromByteArray(value.getData());
+        } catch (Exception ex) {
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+        return result;
+    }
+
+    public HGRandomAccessResult<ValueType> find(KeyType key) {
+        checkOpen();
+        DatabaseEntry keyEntry = new DatabaseEntry(
+                keyConverter.toByteArray(key));
+        DatabaseEntry value = new DatabaseEntry();
+        HGRandomAccessResult result = null;
+        Cursor cursor = null;
+        try {
+            TransactionBDBImpl tx = txn();
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getSearchKey(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
+                result = new SingleKeyResultSet(tx.attachCursor(cursor),
+                        keyEntry, valueConverter);
+            else {
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+                result = HGSearchResult.EMPTY;
+            }
+        } catch (Throwable ex) {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
         }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to ping index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }        
+        return result;
     }
-    
-    public ValueType findFirst(KeyType key)
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry value = new DatabaseEntry();        
-        ValueType result = null;
-        Cursor cursor = null;
-        try
-        {
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-               result = valueConverter.fromByteArray(value.getData());
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        finally
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        }
-        return result;
-    }
-
-    /**
-     * <p>
-     * Find the last entry, assuming ordered duplicates, corresponding to the 
-     * given key.
-     * </p>
-     * 
-     * @param key The key whose last entry is sought.
-     * @return The last (i.e. greatest, i.e. maximum) data value for that key
-     * or null if the set of entries for the key is empty.
-     */
-    public ValueType findLast(KeyType key)
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry value = new DatabaseEntry();        
-        ValueType result = null;
-        Cursor cursor = null;
-        try
-        {
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);            
-            OperationStatus status = cursor.getLast(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-               result = valueConverter.fromByteArray(value.getData());
-        }
-        catch (Exception ex)
-        {
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        finally
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }
-        }
-        return result;
-    }
-    
-    public HGRandomAccessResult<ValueType> find(KeyType key)
-    {
-        checkOpen();
-        DatabaseEntry keyEntry = new DatabaseEntry(keyConverter.toByteArray(key));
-        DatabaseEntry value = new DatabaseEntry();        
-        HGRandomAccessResult result = null;
-        Cursor cursor = null;
-        try
-        {
-        	TransactionBDBImpl tx = txn();
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKey(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS && cursor.count() > 0)
-                result = new SingleKeyResultSet(tx.attachCursor(cursor), keyEntry, valueConverter);
-            else 
-            {
-                try { cursor.close(); } catch (Throwable t) { }
-                result = HGSearchResult.EMPTY;
-            }
-        }
-        catch (Throwable ex)
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }            
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-        return result;        
-    }
-    
-    private HGSearchResult<ValueType> findOrdered(KeyType key, boolean lower_range, boolean compare_equals)
-    {
-        checkOpen();
-/*        if (key == null)
-            throw new HGException("Attempting to lookup index '" + 
-                                  name + "' with a null key."); */
-        byte [] keyAsBytes = keyConverter.toByteArray(key);
-        DatabaseEntry keyEntry = new DatabaseEntry(keyAsBytes);
-        DatabaseEntry value = new DatabaseEntry();
-        Cursor cursor = null;
-        try
-        {
-        	TransactionBDBImpl tx = txn();
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            OperationStatus status = cursor.getSearchKeyRange(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            {       
-            	Comparator<byte[]> comparator = db.getConfig().getType() == DatabaseType.BTREE ? 
-            	            db.getConfig().getBtreeComparator() : db.getConfig().getHashComparator();
-                if (!compare_equals) // strict < or >?
-                {
-                    if (lower_range)
-                        status = cursor.getPrev(keyEntry, value, LockMode.DEFAULT);
-                    else if (comparator.compare(keyAsBytes, keyEntry.getData()) == 0)
-                    	status = cursor.getNextNoDup(keyEntry, value, LockMode.DEFAULT);
+
+    private HGSearchResult<ValueType> findOrdered(KeyType key,
+            boolean lower_range, boolean compare_equals) {
+        checkOpen();
+        /*
+         * if (key == null) throw new HGException("Attempting to lookup index '"
+         * + name + "' with a null key.");
+         */
+        byte[] keyAsBytes = keyConverter.toByteArray(key);
+        DatabaseEntry keyEntry = new DatabaseEntry(keyAsBytes);
+        DatabaseEntry value = new DatabaseEntry();
+        Cursor cursor = null;
+        try {
+            TransactionBDBImpl tx = txn();
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            OperationStatus status = cursor.getSearchKeyRange(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS) {
+                Comparator<byte[]> comparator = db.getConfig()
+                        .getBtreeComparator();
+                if (!compare_equals) // strict < or >?
+                {
+                    if (lower_range)
+                        status = cursor.getPrev(keyEntry, value,
+                                LockMode.DEFAULT);
+                    else if (comparator.compare(keyAsBytes, keyEntry.getData()) == 0)
+                        status = cursor.getNextNoDup(keyEntry, value,
+                                LockMode.DEFAULT);
                 }
-                // BDB cursor will position on the key or on the next element greater than the key
-                // in the latter case we need to back up by one for < (or <=) query
-                else if (lower_range && comparator.compare(keyAsBytes, keyEntry.getData()) != 0)
-                	status = cursor.getPrev(keyEntry, value, LockMode.DEFAULT);
-            }
-            else if (lower_range)
+                // BDB cursor will position on the key or on the next element
+                // greater than the key
+                // in the latter case we need to back up by one for < (or <=)
+                // query
+                else if (lower_range
+                        && comparator.compare(keyAsBytes, keyEntry.getData()) != 0)
+                    status = cursor.getPrev(keyEntry, value, LockMode.DEFAULT);
+            } else if (lower_range)
                 status = cursor.getLast(keyEntry, value, LockMode.DEFAULT);
             else
                 status = cursor.getFirst(keyEntry, value, LockMode.DEFAULT);
-            
-            if (status == OperationStatus.SUCCESS)
-	            if (lower_range)
-	                return new SearchResultWrapper(new KeyRangeBackwardResultSet(tx.attachCursor(cursor), keyEntry, valueConverter));
-	            else
-	                return new SearchResultWrapper(new KeyRangeForwardResultSet(tx.attachCursor(cursor), keyEntry, valueConverter));
-            else
-                try { cursor.close(); } catch (Throwable t) { }
-                return (HGSearchResult<ValueType>)HGSearchResult.EMPTY;
-        }
-        catch (Throwable ex)
-        {
-            if (cursor != null)
-                try { cursor.close(); } catch (Throwable t) { }            
-            throw new HGException("Failed to lookup index '" + 
-                                  name + "': " + ex.toString(), 
-                                  ex);
-        }
-    }
-    
-    public HGSearchResult<ValueType> findGT(KeyType key)
-    {
-        return findOrdered(key, false, false);
-    }
-
-    public HGSearchResult<ValueType> findGTE(KeyType key)
-    {
-        return findOrdered(key, false, true);
-    }
-
-    public HGSearchResult<ValueType> findLT(KeyType key)
-    {
-        return findOrdered(key, true, false);
-    }
-
-    public HGSearchResult<ValueType> findLTE(KeyType key)
-    {
-        return findOrdered(key, true, true);
-    }
-
-    protected void finalize()
-    {
-        if (isOpen())
-            try { close(); } catch (Throwable t) { }
-    }
-
-	public long count()
-	{
-		try
-		{
-			return ((BtreeStats)db.getStats(txn().getBDBTransaction(), null)).getNumKeys();
-		}
-		catch (DatabaseException ex)
-		{
-			throw new HGException(ex);
-		}
-	}
-
-	public long count(KeyType key)
-	{
-        Cursor cursor = null;
-        try
-        {
-            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
-            DatabaseEntry keyEntry = new DatabaseEntry(keyConverter.toByteArray(key));
-            DatabaseEntry value = new DatabaseEntry();                    
-            OperationStatus status = cursor.getSearchKey(keyEntry, value, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            	return cursor.count();
-            else
-            	return 0;
-        }
-        catch (DatabaseException ex)
-        {
-        	throw new HGException(ex);
-        }
-        finally
-        {
-        	if (cursor != null)        
-        		try { cursor.close(); } catch (Throwable t) { }
-        }
-	}    
-}
+
+            if (status == OperationStatus.SUCCESS)
+                if (lower_range)
+                    return new SearchResultWrapper(
+                            new KeyRangeBackwardResultSet(
+                                    tx.attachCursor(cursor), keyEntry,
+                                    valueConverter));
+                else
+                    return new SearchResultWrapper(
+                            new KeyRangeForwardResultSet(
+                                    tx.attachCursor(cursor), keyEntry,
+                                    valueConverter));
+            else
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            return (HGSearchResult<ValueType>) HGSearchResult.EMPTY;
+        } catch (Throwable ex) {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+            throw new HGException("Failed to lookup index '" + name + "': "
+                    + ex.toString(), ex);
+        }
+    }
+
+    public HGSearchResult<ValueType> findGT(KeyType key) {
+        return findOrdered(key, false, false);
+    }
+
+    public HGSearchResult<ValueType> findGTE(KeyType key) {
+        return findOrdered(key, false, true);
+    }
+
+    public HGSearchResult<ValueType> findLT(KeyType key) {
+        return findOrdered(key, true, false);
+    }
+
+    public HGSearchResult<ValueType> findLTE(KeyType key) {
+        return findOrdered(key, true, true);
+    }
+
+    protected void finalize() {
+        if (isOpen())
+            try {
+                close();
+            } catch (Throwable t) {
+            }
+    }
+
+    public long count() {
+        try {
+            return ((BtreeStats) db.getStats(new StatsConfig()))
+                    .getLeafNodeCount();
+        } catch (DatabaseException ex) {
+            throw new HGException(ex);
+        }
+    }
+
+    public long count(KeyType key) {
+        Cursor cursor = null;
+        try {
+            cursor = db.openCursor(txn().getBDBTransaction(), cursorConfig);
+            DatabaseEntry keyEntry = new DatabaseEntry(
+                    keyConverter.toByteArray(key));
+            DatabaseEntry value = new DatabaseEntry();
+            OperationStatus status = cursor.getSearchKey(keyEntry, value,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return cursor.count();
+            else
+                return 0;
+        } catch (DatabaseException ex) {
+            throw new HGException(ex);
+        } finally {
+            if (cursor != null)
+                try {
+                    cursor.close();
+                } catch (Throwable t) {
+                }
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/HGStoreImplementation.java b/src/java/org/hypergraphdb/storage/HGStoreImplementation.java
index 4725baa..0d4a166 100644
--- a/src/java/org/hypergraphdb/storage/HGStoreImplementation.java
+++ b/src/java/org/hypergraphdb/storage/HGStoreImplementation.java
@@ -1,6 +1,7 @@
 package org.hypergraphdb.storage;
 
 import java.util.Comparator;
+
 import org.hypergraphdb.HGConfiguration;
 import org.hypergraphdb.HGIndex;
 import org.hypergraphdb.HGPersistentHandle;
@@ -8,36 +9,48 @@ import org.hypergraphdb.HGRandomAccessResult;
 import org.hypergraphdb.HGStore;
 import org.hypergraphdb.transaction.HGTransactionFactory;
 
-public interface HGStoreImplementation
-{
+public interface HGStoreImplementation {
     Object getConfiguration();
+
     void startup(HGStore store, HGConfiguration configuration);
+
     void shutdown();
-    
+
     HGTransactionFactory getTransactionFactory();
-    
-    HGPersistentHandle store(HGPersistentHandle handle, HGPersistentHandle [] link);
-    HGPersistentHandle [] getLink(HGPersistentHandle handle);
-    //byte [] getLinkData(HGPersistentHandle handle);
+
+    HGPersistentHandle store(HGPersistentHandle handle,
+            HGPersistentHandle[] link);
+
+    HGPersistentHandle[] getLink(HGPersistentHandle handle);
+
+    // byte [] getLinkData(HGPersistentHandle handle);
     void removeLink(HGPersistentHandle handle);
+
     boolean containsLink(HGPersistentHandle handle);
-    
-    HGPersistentHandle store(HGPersistentHandle handle, byte [] data);    
-    void removeData(HGPersistentHandle handle);         
-    byte [] getData(HGPersistentHandle handle);
-    
-    HGRandomAccessResult<HGPersistentHandle> getIncidenceResultSet(HGPersistentHandle handle);
+
+    HGPersistentHandle store(HGPersistentHandle handle, byte[] data);
+
+    void removeData(HGPersistentHandle handle);
+
+    byte[] getData(HGPersistentHandle handle);
+
+    HGRandomAccessResult<HGPersistentHandle> getIncidenceResultSet(
+            HGPersistentHandle handle);
+
     void removeIncidenceSet(HGPersistentHandle handle);
+
     long getIncidenceSetCardinality(HGPersistentHandle handle);
+
     void addIncidenceLink(HGPersistentHandle handle, HGPersistentHandle newLink);
-    void removeIncidenceLink(HGPersistentHandle handle, HGPersistentHandle oldLink);
-    
-    
-    <KeyType, ValueType> HGIndex<KeyType, ValueType> getIndex(String name, 
-                                                              ByteArrayConverter<KeyType> keyConverter, 
-                                                              ByteArrayConverter<ValueType> valueConverter,
-                                                              Comparator<?> comparator,
-                                                              boolean isBidirectional,
-                                                              boolean createIfNecessary);
-    void removeIndex(String name);    
+
+    void removeIncidenceLink(HGPersistentHandle handle,
+            HGPersistentHandle oldLink);
+
+    <KeyType, ValueType> HGIndex<KeyType, ValueType> getIndex(String name,
+            ByteArrayConverter<KeyType> keyConverter,
+            ByteArrayConverter<ValueType> valueConverter,
+            Comparator<?> comparator, boolean isBidirectional,
+            boolean createIfNecessary);
+
+    void removeIndex(String name);
 }
diff --git a/src/java/org/hypergraphdb/storage/HGStoreSubgraph.java b/src/java/org/hypergraphdb/storage/HGStoreSubgraph.java
index b21b0d5..cfdd660 100644
--- a/src/java/org/hypergraphdb/storage/HGStoreSubgraph.java
+++ b/src/java/org/hypergraphdb/storage/HGStoreSubgraph.java
@@ -5,149 +5,141 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
+package org.hypergraphdb.storage;
+
 import java.util.HashSet;
-
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Set;
-
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Set;
+
 import org.hypergraphdb.HGHandle;
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.HGStore;
-import org.hypergraphdb.util.Pair;
-
-/**
- * <p>
- * A {@link StorageGraph} bound to a {@link HGStore}. It's based on a set of root handles
- * and its iterator will traverse the primitive storage graph starting from those roots. 
- * </p>
- * 
- * @author Borislav Iordanov
- *
- */
-public class HGStoreSubgraph implements StorageGraph
-{
-    private Set<HGPersistentHandle> roots;
-    private HGStore store;
-    
-    /**
-     * <p>
-     * Construct a new {@link HGStore} based {@link StorageGraph} 
-     * </p>
-     * @param root A single root, starting point of the storage graph.
-     * @param store The backing store instance.
-     */
-    public HGStoreSubgraph(HGHandle root, HGStore store)
-    {
-        this.roots = new HashSet<HGPersistentHandle>();
-        this.roots.add(root.getPersistent());
-        this.store = store;
-    }
-    
-    /**
-     * <p>
-     * Construct a new {@link HGStore} based {@link StorageGraph}
-     * with multiple roots. 
-     * </p>
-     * @param root A single root, starting point of the storage graph.
-     * @param store The backing store instance.
-     */
-    public HGStoreSubgraph(Set<HGHandle> roots, HGStore store)
-    {
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.HGStore;
+import org.hypergraphdb.util.Pair;
+
+/**
+ * <p>
+ * A {@link StorageGraph} bound to a {@link HGStore}. It's based on a set of
+ * root handles and its iterator will traverse the primitive storage graph
+ * starting from those roots.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ * 
+ */
+public class HGStoreSubgraph implements StorageGraph {
+    private Set<HGPersistentHandle> roots;
+    private HGStore store;
+
+    /**
+     * <p>
+     * Construct a new {@link HGStore} based {@link StorageGraph}
+     * </p>
+     * 
+     * @param root
+     *            A single root, starting point of the storage graph.
+     * @param store
+     *            The backing store instance.
+     */
+    public HGStoreSubgraph(HGHandle root, HGStore store) {
+        this.roots = new HashSet<HGPersistentHandle>();
+        this.roots.add(root.getPersistent());
+        this.store = store;
+    }
+
+    /**
+     * <p>
+     * Construct a new {@link HGStore} based {@link StorageGraph} with multiple
+     * roots.
+     * </p>
+     * 
+     * @param root
+     *            A single root, starting point of the storage graph.
+     * @param store
+     *            The backing store instance.
+     */
+    public HGStoreSubgraph(Set<HGHandle> roots, HGStore store) {
         this.roots = new HashSet<HGPersistentHandle>();
         for (HGHandle root : roots)
             this.roots.add(root.getPersistent());
-        this.store = store;
-    }
-
-    
-    public byte[] getData(HGPersistentHandle handle)
-    {
-        return store.getData(handle);
-    }
-
-    public HGPersistentHandle[] getLink(HGPersistentHandle handle)
-    {
-        return store.getLink(handle);
-    }
+        this.store = store;
+    }
+
+    public byte[] getData(HGPersistentHandle handle) {
+        return store.getData(handle);
+    }
+
+    public HGPersistentHandle[] getLink(HGPersistentHandle handle) {
+        return store.getLink(handle);
+    }
 
     public HGPersistentHandle store(HGPersistentHandle handle,
-                                    HGPersistentHandle[] link)
-    {
+            HGPersistentHandle[] link) {
         return store.store(handle, link);
     }
 
-    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data)
-    {
+    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data) {
         return store.store(handle, data);
     }
 
-    public Set<HGPersistentHandle> getRoots()
-    {
-        return roots;
-    }
-
-    public Iterator<Pair<HGPersistentHandle, Object>> iterator()
-    {
-        return new SubgraphIterator();
-    }
-
-    private class SubgraphIterator implements Iterator<Pair<HGPersistentHandle, Object>>
-    {
-        LinkedList<HGPersistentHandle> remaining = new LinkedList<HGPersistentHandle>();
-        HashSet<HGPersistentHandle> visited = new HashSet<HGPersistentHandle>();
-        
-        public SubgraphIterator()
-        {
-            for (HGPersistentHandle root : roots)
-                remaining.addLast(root);
-            
-            //TODO some UUIDs should not be visited?
-            visited.add(store.getTransactionManager().getHyperGraph().getHandleFactory().nullHandle());
-        }
-        
-        public boolean hasNext()
-        {
-            return !remaining.isEmpty();
-        }
-
-        public Pair<HGPersistentHandle, Object> next()
-        {
-            Pair<HGPersistentHandle, Object> result = null;
-            HGPersistentHandle h = remaining.removeFirst();
-            HGPersistentHandle[] link = store.getLink(h);
-           
-            if (link == null)
-            {
-                byte [] data = store.getData(h);
-                //TODO throw exception for missing data
-                if (data != null) 
-                {
-                    visited.add(h);
-                    result = new Pair<HGPersistentHandle, Object>(h, data);
-                }
-           }
-           else
-           {
-               visited.add(h);
-               for (HGPersistentHandle x : link)
-               {                   
-                   // do we want to prevent null from being returned...it's legit for some 
-                   if (!visited.contains(x) /* && (store.getData(x) != null || store.getLink(x) != null) */ ) 
-                       remaining.addLast(x);
-               }
-
-               result = new Pair<HGPersistentHandle, Object>(h, link);
-           }
-
-           return result;
-       }
-
-       public void remove()
-       {
-           throw new UnsupportedOperationException();
-       }
-    }    
+    public Set<HGPersistentHandle> getRoots() {
+        return roots;
+    }
+
+    public Iterator<Pair<HGPersistentHandle, Object>> iterator() {
+        return new SubgraphIterator();
+    }
+
+    private class SubgraphIterator implements
+            Iterator<Pair<HGPersistentHandle, Object>> {
+        LinkedList<HGPersistentHandle> remaining = new LinkedList<HGPersistentHandle>();
+        HashSet<HGPersistentHandle> visited = new HashSet<HGPersistentHandle>();
+
+        public SubgraphIterator() {
+            for (HGPersistentHandle root : roots)
+                remaining.addLast(root);
+
+            // TODO some UUIDs should not be visited?
+            visited.add(store.getTransactionManager().getHyperGraph()
+                    .getHandleFactory().nullHandle());
+        }
+
+        public boolean hasNext() {
+            return !remaining.isEmpty();
+        }
+
+        public Pair<HGPersistentHandle, Object> next() {
+            Pair<HGPersistentHandle, Object> result = null;
+            HGPersistentHandle h = remaining.removeFirst();
+            HGPersistentHandle[] link = store.getLink(h);
+
+            if (link == null) {
+                byte[] data = store.getData(h);
+                // TODO throw exception for missing data
+                if (data != null) {
+                    visited.add(h);
+                    result = new Pair<HGPersistentHandle, Object>(h, data);
+                }
+            } else {
+                visited.add(h);
+                for (HGPersistentHandle x : link) {
+                    // do we want to prevent null from being returned...it's
+                    // legit for some
+                    if (!visited.contains(x) /*
+                                              * && (store.getData(x) != null ||
+                                              * store.getLink(x) != null)
+                                              */)
+                        remaining.addLast(x);
+                }
+
+                result = new Pair<HGPersistentHandle, Object>(h, link);
+            }
+
+            return result;
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/IndexResultSet.java b/src/java/org/hypergraphdb/storage/IndexResultSet.java
index 319028e..0cf7dce 100644
--- a/src/java/org/hypergraphdb/storage/IndexResultSet.java
+++ b/src/java/org/hypergraphdb/storage/IndexResultSet.java
@@ -5,379 +5,311 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.NoSuchElementException;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.transaction.BDBTxCursor;
-import org.hypergraphdb.util.HGUtils;
-
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.OperationStatus;
-
-/**
- * <p>
- * An <code>IndexResultSet</code> is based on a cursor over an indexed set of values.
- * Implementation of complex query execution may move the cursor position based on some
- * index key to speed up query processing.  
- * </p>
- * 
- * @author Borislav Iordanov
- */
-@SuppressWarnings("unchecked")
-public abstract class IndexResultSet<T> implements HGRandomAccessResult<T>
-{        
-	private static final Object UNKNOWN = new Object();
-	
-    protected BDBTxCursor cursor;
-    protected Object current = UNKNOWN, prev = UNKNOWN, next = UNKNOWN;    
-    protected DatabaseEntry key;        
-    protected DatabaseEntry data;
-    protected ByteArrayConverter<T> converter;
+package org.hypergraphdb.storage;
+
+import java.util.NoSuchElementException;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.transaction.BDBTxCursor;
+import org.hypergraphdb.util.HGUtils;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+
+/**
+ * <p>
+ * An <code>IndexResultSet</code> is based on a cursor over an indexed set of
+ * values. Implementation of complex query execution may move the cursor
+ * position based on some index key to speed up query processing.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+@SuppressWarnings("unchecked")
+public abstract class IndexResultSet<T> implements HGRandomAccessResult<T> {
+    private static final Object UNKNOWN = new Object();
+
+    protected BDBTxCursor cursor;
+    protected Object current = UNKNOWN, prev = UNKNOWN, next = UNKNOWN;
+    protected DatabaseEntry key;
+    protected DatabaseEntry data;
+    protected ByteArrayConverter<T> converter;
     protected int lookahead = 0;
-    
-    protected final void closeNoException()
-    {
-        try { close(); } catch (Throwable t) { }
-    }
-    
-    protected final void checkCursor()
-    {
-        if (!cursor.isOpen())
-            throw new HGException(
-                    "DefaultIndexImpl.IndexResultSet: attempt to perform an operation on a closed or invalid cursor.");            
-    }
-    
-    /**
-     * 
-     * <p>
-     * Copy <code>data</code> into the <code>entry</code>. Adjust <code>entry</code>'s
-     * byte buffer if needed.
-     * </p>
-     *
-     * @param entry
-     * @param data
-     */
-    protected void assignData(DatabaseEntry entry, byte [] data)
-    {
-    	byte [] dest = entry.getData();
-    	if (dest == null || dest.length != data.length)
-    	{
-    		dest = new byte[data.length];
-    		entry.setData(dest);
-    	}
-    	System.arraycopy(data, 0, dest, 0, data.length);
-    }
-    
-    protected final void moveNext()
-    {
-//        checkCursor();
-        prev = current;
-        current = next;
-        next = UNKNOWN;
-        lookahead--;
-/*        while (true)
-        {
-        	next = advance();
-        	if (next == null)
-        		break;
-        	if (++lookahead == 1)
-        		break;
-        } */
-    }
-    
-    protected final void movePrev()
-    {
-//        checkCursor();
-        next = current;
-        current = prev;
-        prev = UNKNOWN;
-        lookahead++;
-/*        while (true)
-        {
-        	prev = back();
-        	if (prev == null)
-        		break;
-        	if (--lookahead == -1)
-        		break;
-        } */
-    }
-    
-    protected abstract T advance();
-    protected abstract T back();
-    
-    /**
-     * <p>Construct an empty result set.</p>
-     */
-    protected IndexResultSet()
-    {
-    }
-    
-//    static int idcounter = 0;    
-//    int id = 0;
-    
-    /**
-     * <p>Construct a result set matching a specific key.</p>
-     * 
-     * @param cursor
-     * @param key
-     */
-    public IndexResultSet(BDBTxCursor cursor, DatabaseEntry keyIn, ByteArrayConverter<T> converter)
-    {
-/*        id = idcounter++;
-        System.out.println("Constructing index set with id " + id);
-        StackTraceElement e[]=Thread.currentThread().getStackTrace();
-        for (int i=0; i <e.length; i++) {
-             System.out.println(e[i]);
-            } */
-        this.converter = converter;
-        this.cursor = cursor;
+
+    protected final void closeNoException() {
+        try {
+            close();
+        } catch (Throwable t) {
+        }
+    }
+
+    protected final void checkCursor() {
+        if (!cursor.isOpen())
+            throw new HGException(
+                    "DefaultIndexImpl.IndexResultSet: attempt to perform an operation on a closed or invalid cursor.");
+    }
+
+    /**
+     * 
+     * <p>
+     * Copy <code>data</code> into the <code>entry</code>. Adjust
+     * <code>entry</code>'s byte buffer if needed.
+     * </p>
+     * 
+     * @param entry
+     * @param data
+     */
+    protected void assignData(DatabaseEntry entry, byte[] data) {
+        byte[] dest = entry.getData();
+        if (dest == null || dest.length != data.length) {
+            dest = new byte[data.length];
+            entry.setData(dest);
+        }
+        System.arraycopy(data, 0, dest, 0, data.length);
+    }
+
+    protected final void moveNext() {
+        // checkCursor();
+        prev = current;
+        current = next;
+        next = UNKNOWN;
+        lookahead--;
+        /*
+         * while (true) { next = advance(); if (next == null) break; if
+         * (++lookahead == 1) break; }
+         */
+    }
+
+    protected final void movePrev() {
+        // checkCursor();
+        next = current;
+        current = prev;
+        prev = UNKNOWN;
+        lookahead++;
+        /*
+         * while (true) { prev = back(); if (prev == null) break; if
+         * (--lookahead == -1) break; }
+         */
+    }
+
+    protected abstract T advance();
+
+    protected abstract T back();
+
+    /**
+     * <p>
+     * Construct an empty result set.
+     * </p>
+     */
+    protected IndexResultSet() {
+    }
+
+    // static int idcounter = 0;
+    // int id = 0;
+
+    /**
+     * <p>
+     * Construct a result set matching a specific key.
+     * </p>
+     * 
+     * @param cursor
+     * @param key
+     */
+    public IndexResultSet(BDBTxCursor cursor, DatabaseEntry keyIn,
+            ByteArrayConverter<T> converter) {
+        /*
+         * id = idcounter++;
+         * System.out.println("Constructing index set with id " + id);
+         * StackTraceElement e[]=Thread.currentThread().getStackTrace(); for
+         * (int i=0; i <e.length; i++) { System.out.println(e[i]); }
+         */
+        this.converter = converter;
+        this.cursor = cursor;
         this.key = new DatabaseEntry();
         this.data = new DatabaseEntry();
-        // TODO: for fixed size key and data,we should actually reuse the buffers, but
-        // this has to be passed somehow as a configuration parameter to the HGIndex
-        // implementation and down to result sets. It's a worthwhile optimization.
-        this.key.setReuseBuffer(false);
-        this.data.setReuseBuffer(false);
-        if (keyIn != null)
-        	assignData(this.key, keyIn.getData());
-	    try
-	    {
-	        cursor.cursor().getCurrent(key, data, LockMode.DEFAULT);
-	        next = converter.fromByteArray(data.getData());
-	        lookahead = 1;
-	    }
-	    catch (Throwable t)
-	    {
-	        throw new HGException(t);
-	    }
-    }
-
-    protected void positionToCurrent(byte [] data)
-    {
-		current = converter.fromByteArray(data);
-       	lookahead = 0;
-        prev = next = UNKNOWN;
-    }
-    
-    public void goBeforeFirst()
-    {
-        try
-        {
-            if (cursor.cursor().getFirst(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-            {
+        if (keyIn != null)
+            assignData(this.key, keyIn.getData());
+        try {
+            cursor.cursor().getCurrent(key, data, LockMode.DEFAULT);
+            next = converter.fromByteArray(data.getData());
+            lookahead = 1;
+        } catch (Throwable t) {
+            throw new HGException(t);
+        }
+    }
+
+    protected void positionToCurrent(byte[] data) {
+        current = converter.fromByteArray(data);
+        lookahead = 0;
+        prev = next = UNKNOWN;
+    }
+
+    public void goBeforeFirst() {
+        try {
+            if (cursor.cursor().getFirst(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                 current = UNKNOWN;
                 prev = null;
                 next = converter.fromByteArray(data.getData());
                 lookahead = 1;
-            }
-            else
-            {
+            } else {
                 prev = next = null;
                 current = UNKNOWN;
                 lookahead = 0;
             }
-        }
-        catch (Throwable t)
-        {
+        } catch (Throwable t) {
             closeNoException();
             throw new HGException(t);
-        }            
+        }
     }
-    
-    public void goAfterLast()
-    {
-        try
-        {
-            if (cursor.cursor().getLast(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-            {
+
+    public void goAfterLast() {
+        try {
+            if (cursor.cursor().getLast(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                 current = UNKNOWN;
                 next = null;
                 prev = converter.fromByteArray(data.getData());
                 lookahead = -1;
-            }
-            else
-            {
+            } else {
                 prev = next = null;
                 current = UNKNOWN;
                 lookahead = 0;
-            }            
+            }
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
         }
-        catch (Throwable t)
-        {
+    }
+
+    public GotoResult goTo(T value, boolean exactMatch) {
+        byte[] B = converter.toByteArray(value);
+        assignData(data, B);
+        try {
+            OperationStatus status = null;
+            if (exactMatch) {
+                status = cursor.cursor().getSearchBoth(key, data,
+                        LockMode.DEFAULT);
+                if (status == OperationStatus.SUCCESS) {
+                    positionToCurrent(data.getData());
+                    return GotoResult.found;
+                } else
+                    return GotoResult.nothing;
+            } else {
+                status = cursor.cursor().getSearchBothRange(key, data,
+                        LockMode.DEFAULT);
+                if (status == OperationStatus.SUCCESS) {
+                    GotoResult result = HGUtils.eq(B, data.getData()) ? GotoResult.found
+                            : GotoResult.close;
+                    positionToCurrent(data.getData());
+                    return result;
+                } else
+                    return GotoResult.nothing;
+            }
+        } catch (Throwable t) {
             closeNoException();
             throw new HGException(t);
-        }        
+        }
+    }
+
+    public final void close() {
+        if (cursor == null)
+            return;
+
+        try {
+            current = next = prev = UNKNOWN;
+            key = null;
+            cursor.close();
+        } catch (Throwable t) {
+            throw new HGException(
+                    "Exception while closing a DefaultIndexImpl cursor: "
+                            + t.toString(), t);
+        } finally {
+            cursor = null;
+        }
+    }
+
+    public final T current() {
+        if (current == UNKNOWN)
+            throw new NoSuchElementException();
+        return (T) current;
     }
-    
-    public GotoResult goTo(T value, boolean exactMatch)
-    {
-    	byte [] B = converter.toByteArray(value);
-    	assignData(data, B);
-    	try
-    	{
-    	    OperationStatus status = null;
-    		if (exactMatch)
-    		{
-    		    status = cursor.cursor().getSearchBoth(key, data, LockMode.DEFAULT);
-    			if (status == OperationStatus.SUCCESS)
-    			{
-    				positionToCurrent(data.getData());
-    				return GotoResult.found; 
-    			}
-    			else
-    				return GotoResult.nothing;
-    		}
-    		else 
-    		{
-    		    status = cursor.cursor().getSearchBothRange(key, data, LockMode.DEFAULT);
-    			if (status == OperationStatus.SUCCESS)
-    			{
-    				GotoResult result = HGUtils.eq(B, data.getData()) ? GotoResult.found : GotoResult.close; 
-    				positionToCurrent(data.getData());
-    				return result;
-    			}    				
-    			else
-    				return GotoResult.nothing;
-    		}
-    	}
-    	catch (Throwable t)
-    	{
-    		closeNoException();
-    		throw new HGException(t);
-    	}
-    }
-    
-    public final void close()
-    {
-        if (cursor == null)
-            return;
-
-        try
-        {
-            current = next = prev = UNKNOWN;
-            key = null;
-            cursor.close();
-        }
-        catch (Throwable t)
-        {
-            throw new HGException("Exception while closing a DefaultIndexImpl cursor: " +
-                                  t.toString(), t);
-        }
-        finally
-        {
-            cursor = null;
-        }
-    }
-    
-    public final T current()     
-    {
-    	if (current == UNKNOWN)
-    		throw new NoSuchElementException();
-    	return (T)current; 
-    }
-    
-    public final boolean hasPrev()    
-    {
-    	if (prev == UNKNOWN)
-    	{
-    	    while (lookahead > -1)
-    	    {
-    	        prev = back();
-    	        if (prev == null)
-    	            break;
-    	        lookahead--;
-    	    }
-//    		prev = back();
-    	}
-    	return prev != null; 
-    }
-    
-    public final boolean hasNext()    
-    { 
-    	if (next == UNKNOWN)
-    	{
-            while (lookahead < 1)
-            {
+
+    public final boolean hasPrev() {
+        if (prev == UNKNOWN) {
+            while (lookahead > -1) {
+                prev = back();
+                if (prev == null)
+                    break;
+                lookahead--;
+            }
+            // prev = back();
+        }
+        return prev != null;
+    }
+
+    public final boolean hasNext() {
+        if (next == UNKNOWN) {
+            while (lookahead < 1) {
                 next = advance();
                 if (next == null)
                     break;
                 lookahead++;
-            }    	    
-//    		next = advance();
-    	}
-    	return next != null; 
-    }
-    
-    public final T prev()        
-    { 
-    	if (!hasPrev())
-    		throw new NoSuchElementException();
-    	movePrev(); 
-    	return current(); 
-    }
-            
-    public final T next()        
-    { 
-    	if (!hasNext())
-    		throw new NoSuchElementException();
-    	moveNext(); 
-    	return current(); 
-    }
-    
-    public final void remove()
-    {
-        throw new UnsupportedOperationException(
-                "HG - IndexResultSet does not implement remove.");
-    }
-    
-    protected void finalize()
-    {
-/*        if (cursor != null)
-        {
-            
-            System.out.print("WARNING: set id " + id +  " closing unclosed cursor in finalizer method -- DB is: "); 
-            try
-            {
-                System.out.println(cursor.getDatabase().getDatabaseName());
-            }
-            catch (Exception ex)
-            {
-                ex.printStackTrace(System.err);
-            }
-        } */
-        closeNoException();
-    }
-    
-    public int count()
-    {
-    	try
-    	{
-    		return cursor.cursor().count();
-    	}
-    	catch (DatabaseException ex)
-    	{
-    		throw new HGException(ex);
-    	}
-    }
-    
-    /**
-     * Remove current element. After that cursor becomes invalid, so next(), prev()
-     * operations will fail. However, a goTo operation should work. 
-     */
-    public void removeCurrent()
-    {
-    	try
-    	{
-    		cursor.cursor().delete();
-    	}
-    	catch (DatabaseException ex)
-    	{
-    		throw new HGException(ex);
-    	}
-    }
-}
+            }
+            // next = advance();
+        }
+        return next != null;
+    }
+
+    public final T prev() {
+        if (!hasPrev())
+            throw new NoSuchElementException();
+        movePrev();
+        return current();
+    }
+
+    public final T next() {
+        if (!hasNext())
+            throw new NoSuchElementException();
+        moveNext();
+        return current();
+    }
+
+    public final void remove() {
+        throw new UnsupportedOperationException(
+                "HG - IndexResultSet does not implement remove.");
+    }
+
+    protected void finalize() {
+        /*
+         * if (cursor != null) {
+         * 
+         * System.out.print("WARNING: set id " + id +
+         * " closing unclosed cursor in finalizer method -- DB is: "); try {
+         * System.out.println(cursor.getDatabase().getDatabaseName()); } catch
+         * (Exception ex) { ex.printStackTrace(System.err); } }
+         */
+        closeNoException();
+    }
+
+    public int count() {
+        try {
+            return cursor.cursor().count();
+        } catch (DatabaseException ex) {
+            throw new HGException(ex);
+        }
+    }
+
+    /**
+     * Remove current element. After that cursor becomes invalid, so next(),
+     * prev() operations will fail. However, a goTo operation should work.
+     */
+    public void removeCurrent() {
+        try {
+            cursor.cursor().delete();
+        } catch (DatabaseException ex) {
+            throw new HGException(ex);
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/KeyRangeBackwardResultSet.java b/src/java/org/hypergraphdb/storage/KeyRangeBackwardResultSet.java
index 876b6a5..7d5da55 100644
--- a/src/java/org/hypergraphdb/storage/KeyRangeBackwardResultSet.java
+++ b/src/java/org/hypergraphdb/storage/KeyRangeBackwardResultSet.java
@@ -5,65 +5,57 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.transaction.BDBTxCursor;
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.transaction.BDBTxCursor;
 import org.hypergraphdb.util.HGUtils;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-
-class KeyRangeBackwardResultSet<T> extends IndexResultSet<T>
-{    
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+
+class KeyRangeBackwardResultSet<T> extends IndexResultSet<T> {
     private DatabaseEntry initialKey = null;
-    
-    protected T advance()
-    {
-        try
-        {
-            OperationStatus status = cursor.cursor().getPrev(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }            
-    }
-    
-    protected T back()
-    {
+
+    protected T advance() {
+        try {
+            OperationStatus status = cursor.cursor().getPrev(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    protected T back() {
         if (HGUtils.eq(key.getData(), initialKey.getData()))
-            return null;        
-        try
-        {
-            OperationStatus status = cursor.cursor().getNext(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }                        
-    }
-
-    public KeyRangeBackwardResultSet(BDBTxCursor cursor, DatabaseEntry key,  ByteArrayConverter<T> converter)
-    {
-        super(cursor, key, converter);     
+            return null;
+        try {
+            OperationStatus status = cursor.cursor().getNext(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    public KeyRangeBackwardResultSet(BDBTxCursor cursor, DatabaseEntry key,
+            ByteArrayConverter<T> converter) {
+        super(cursor, key, converter);
         initialKey = new DatabaseEntry();
-        assignData(initialKey, key.getData());                
-    }
-    
-    public boolean isOrdered()
-    {
-    	return true;
-    }
+        assignData(initialKey, key.getData());
+    }
+
+    public boolean isOrdered() {
+        return true;
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/KeyRangeForwardResultSet.java b/src/java/org/hypergraphdb/storage/KeyRangeForwardResultSet.java
index 0ade29b..6bba967 100644
--- a/src/java/org/hypergraphdb/storage/KeyRangeForwardResultSet.java
+++ b/src/java/org/hypergraphdb/storage/KeyRangeForwardResultSet.java
@@ -5,67 +5,57 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.transaction.BDBTxCursor;
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.transaction.BDBTxCursor;
 import org.hypergraphdb.util.HGUtils;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-
-class KeyRangeForwardResultSet<T> extends IndexResultSet<T>
-{    
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+
+class KeyRangeForwardResultSet<T> extends IndexResultSet<T> {
     private DatabaseEntry initialKey = null;
-    
-    protected T advance()
-    {
-        try
-        {
-            OperationStatus status = cursor.cursor().getNext(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            	return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }            
-    }
-    
-    protected T back()
-    {
+
+    protected T advance() {
+        try {
+            OperationStatus status = cursor.cursor().getNext(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    protected T back() {
         if (HGUtils.eq(key.getData(), initialKey.getData()))
-            return null;
-        try
-        {
-            OperationStatus status = cursor.cursor().getPrev(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }                        
+            return null;
+        try {
+            OperationStatus status = cursor.cursor().getPrev(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
     }
-    
-    
-    
-    public KeyRangeForwardResultSet(BDBTxCursor cursor, DatabaseEntry key, ByteArrayConverter<T> converter)
-    {
+
+    public KeyRangeForwardResultSet(BDBTxCursor cursor, DatabaseEntry key,
+            ByteArrayConverter<T> converter) {
         super(cursor, key, converter);
         initialKey = new DatabaseEntry();
-        assignData(initialKey, key.getData());        
-    }        
-    
-    public boolean isOrdered()
-    {
-    	return true;
-    }
-}
+        assignData(initialKey, key.getData());
+    }
+
+    public boolean isOrdered() {
+        return true;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/KeyScanResultSet.java b/src/java/org/hypergraphdb/storage/KeyScanResultSet.java
index b4a41d5..863769e 100644
--- a/src/java/org/hypergraphdb/storage/KeyScanResultSet.java
+++ b/src/java/org/hypergraphdb/storage/KeyScanResultSet.java
@@ -5,127 +5,102 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.transaction.BDBTxCursor;
-import org.hypergraphdb.util.HGUtils;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-
-/**
- * 
- * <p>
- * Scans the key elements of an index. Similar to KeyRangeForwardResultSet, but
- * instead of returning the data, it returns the keys. 
- * </p>
- *
- * @author Borislav Iordanov
- *
- */
-public class KeyScanResultSet<T> extends IndexResultSet<T>
-{
-
-	@Override
-	protected T advance()
-	{
-        try
-        {
-            OperationStatus status = cursor.cursor().getNextNoDup(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-            	return converter.fromByteArray(key.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }      
-    }
-
-	@Override
-	protected T back()
-	{
-        try
-        {
-            OperationStatus status = cursor.cursor().getPrevNoDup(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(key.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        } 
-    }
-
-	public boolean isOrdered()
-	{
-		return true;
-	}
-    
-    public KeyScanResultSet(BDBTxCursor cursor, DatabaseEntry keyIn, ByteArrayConverter<T> converter)
-    {
-        this.converter = converter;
-        this.cursor = cursor;
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.transaction.BDBTxCursor;
+import org.hypergraphdb.util.HGUtils;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+
+/**
+ * 
+ * <p>
+ * Scans the key elements of an index. Similar to KeyRangeForwardResultSet, but
+ * instead of returning the data, it returns the keys.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ * 
+ */
+public class KeyScanResultSet<T> extends IndexResultSet<T> {
+
+    @Override
+    protected T advance() {
+        try {
+            OperationStatus status = cursor.cursor().getNextNoDup(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(key.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    @Override
+    protected T back() {
+        try {
+            OperationStatus status = cursor.cursor().getPrevNoDup(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(key.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    public boolean isOrdered() {
+        return true;
+    }
+
+    public KeyScanResultSet(BDBTxCursor cursor, DatabaseEntry keyIn,
+            ByteArrayConverter<T> converter) {
+        this.converter = converter;
+        this.cursor = cursor;
         this.key = new DatabaseEntry();
         this.data = new DatabaseEntry();
-        // TODO: for fixed size key and data,we should actually reuse the buffers, but
-        // this has to be passed somehow as a configuration parameter to the HGIndex
-        // implementation and down to result sets. It's a worthwhile optimization.
-        this.key.setReuseBuffer(false);
-        this.data.setReuseBuffer(false);
-
-        if (keyIn != null)
-        	assignData(key, keyIn.getData());
-	    try
-	    {
-	        cursor.cursor().getCurrent(key, data, LockMode.DEFAULT);
-	        next = converter.fromByteArray(key.getData());
-	        lookahead = 1;
-	    }
-	    catch (Throwable t)
-	    {
-	        throw new HGException(t);
-	    }         
-    } 	
-    
-    public GotoResult goTo(T value, boolean exactMatch)
-    {
-    	byte [] B = converter.toByteArray(value);
-    	assignData(key, B);
-    	try
-    	{
-    		if (exactMatch)
-    		{
-    			if (cursor.cursor().getSearchKey(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-    			{
-    				positionToCurrent(key.getData());
-    				return GotoResult.found;
-    			}
-    			else
-    				return GotoResult.nothing;
-    		}
-    		else 
-    		{
-    			if (cursor.cursor().getSearchKeyRange(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-    			{
-    				positionToCurrent(key.getData());    				
-    				return HGUtils.eq(B, key.getData()) ? GotoResult.found : GotoResult.close;
-    			}
-    			else
-    				return GotoResult.nothing;    			
-    		}
-    	}
-    	catch (Throwable t)
-    	{
-    		closeNoException();
-    		throw new HGException(t);
-    	}
-    }        
-}
+
+        if (keyIn != null)
+            assignData(key, keyIn.getData());
+        try {
+            cursor.cursor().getCurrent(key, data, LockMode.DEFAULT);
+            next = converter.fromByteArray(key.getData());
+            lookahead = 1;
+        } catch (Throwable t) {
+            throw new HGException(t);
+        }
+    }
+
+    public GotoResult goTo(T value, boolean exactMatch) {
+        byte[] B = converter.toByteArray(value);
+        assignData(key, B);
+        try {
+            if (exactMatch) {
+                if (cursor.cursor().getSearchKey(key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
+                    positionToCurrent(key.getData());
+                    return GotoResult.found;
+                } else
+                    return GotoResult.nothing;
+            } else {
+                if (cursor.cursor().getSearchKeyRange(key, data,
+                        LockMode.DEFAULT) == OperationStatus.SUCCESS) {
+                    positionToCurrent(key.getData());
+                    return HGUtils.eq(B, key.getData()) ? GotoResult.found
+                            : GotoResult.close;
+                } else
+                    return GotoResult.nothing;
+            }
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/LinkBinding.java b/src/java/org/hypergraphdb/storage/LinkBinding.java
index ad59d89..a2a884f 100644
--- a/src/java/org/hypergraphdb/storage/LinkBinding.java
+++ b/src/java/org/hypergraphdb/storage/LinkBinding.java
@@ -5,66 +5,63 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import com.sleepycat.bind.tuple.TupleBinding;
-import com.sleepycat.bind.tuple.TupleInput;
-import com.sleepycat.bind.tuple.TupleOutput;
-import org.hypergraphdb.HGException;
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
 import org.hypergraphdb.HGHandleFactory;
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.HyperGraph;
-
-/**
- * <p>
- * A <code>LinkBinding</code> converts a <code>UUIDPersistentHandle[]</code>
- * to and from a flat <code>byte[]</code> for the purposes of storage and
- * retrieval in the BerkeleyDB.
- * </p>
- * 
- * @author Borislav Iordanov
- */
-public class LinkBinding extends TupleBinding<HGPersistentHandle[]>
-{
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.HyperGraph;
+
+import com.sleepycat.bind.tuple.TupleBinding;
+import com.sleepycat.bind.tuple.TupleInput;
+import com.sleepycat.bind.tuple.TupleOutput;
+
+/**
+ * <p>
+ * A <code>LinkBinding</code> converts a <code>UUIDPersistentHandle[]</code> to
+ * and from a flat <code>byte[]</code> for the purposes of storage and retrieval
+ * in the BerkeleyDB.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public class LinkBinding extends TupleBinding<HGPersistentHandle[]> {
     private HGHandleFactory handleFactory;
     private int handleSize;
-    
-    public LinkBinding(HGHandleFactory handleFactory)
-    {
+
+    public LinkBinding(HGHandleFactory handleFactory) {
         this.handleFactory = handleFactory;
         handleSize = handleFactory.nullHandle().toByteArray().length;
     }
-    
-	public HGPersistentHandle [] readHandles(byte [] buffer, int offset, int length)
-	{
-        if (length == 0)
-            return HyperGraph.EMPTY_PERSISTENT_HANDLE_SET;
-        int handle_count = length / handleSize;
-        HGPersistentHandle [] handles = new HGPersistentHandle[handle_count];
-        for (int i = 0; i < handle_count; i++)
-            handles[i] = handleFactory.makeHandle(buffer, offset + i*handleSize);
-        return handles;
-	}
-	
-    public HGPersistentHandle[] entryToObject(TupleInput input)
-    {
-        int size = input.getBufferLength() - input.getBufferOffset();
-        if (size % handleSize != 0)
-            throw new HGException("While reading link tuple: the value buffer size is not a multiple of the handle size.");
-        else
-        	return readHandles(input.getBufferBytes(), 0, size);
-    }
-
-    public void objectToEntry(HGPersistentHandle[] link, TupleOutput output)
-    {
-        byte [] buffer = new byte[link.length * handleSize];
-        for (int i = 0; i < link.length; i++)
-        {
-            HGPersistentHandle handle = (HGPersistentHandle)link[i];
-            System.arraycopy(handle.toByteArray(), 0, 
-                             buffer, i*handleSize, 
-                             handleSize);            
-        }
-        output.writeFast(buffer);
-    }
+
+    public HGPersistentHandle[] readHandles(byte[] buffer, int offset,
+            int length) {
+        if (length == 0)
+            return HyperGraph.EMPTY_PERSISTENT_HANDLE_SET;
+        int handle_count = length / handleSize;
+        HGPersistentHandle[] handles = new HGPersistentHandle[handle_count];
+        for (int i = 0; i < handle_count; i++)
+            handles[i] = handleFactory.makeHandle(buffer, offset + i
+                    * handleSize);
+        return handles;
+    }
+
+    public HGPersistentHandle[] entryToObject(TupleInput input) {
+        int size = input.getBufferLength() - input.getBufferOffset();
+        if (size % handleSize != 0)
+            throw new HGException(
+                    "While reading link tuple: the value buffer size is not a multiple of the handle size.");
+        else
+            return readHandles(input.getBufferBytes(), 0, size);
+    }
+
+    public void objectToEntry(HGPersistentHandle[] link, TupleOutput output) {
+        byte[] buffer = new byte[link.length * handleSize];
+        for (int i = 0; i < link.length; i++) {
+            HGPersistentHandle handle = (HGPersistentHandle) link[i];
+            System.arraycopy(handle.toByteArray(), 0, buffer, i * handleSize,
+                    handleSize);
+        }
+        output.writeFast(buffer);
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/PlainSecondaryKeyCreator.java b/src/java/org/hypergraphdb/storage/PlainSecondaryKeyCreator.java
index 11d7cbb..d089bea 100644
--- a/src/java/org/hypergraphdb/storage/PlainSecondaryKeyCreator.java
+++ b/src/java/org/hypergraphdb/storage/PlainSecondaryKeyCreator.java
@@ -5,31 +5,27 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.SecondaryDatabase;
-import com.sleepycat.db.SecondaryKeyCreator;
-
-public class PlainSecondaryKeyCreator implements SecondaryKeyCreator
-{
-    private static final PlainSecondaryKeyCreator instance = new PlainSecondaryKeyCreator();
-    
-    private PlainSecondaryKeyCreator()
-    {        
-    }
-    
-    public static PlainSecondaryKeyCreator getInstance()
-    {
-        return instance;
-    }
-    
-    public boolean createSecondaryKey(SecondaryDatabase secondary,
-            DatabaseEntry key, DatabaseEntry data, DatabaseEntry result)
-            throws DatabaseException
-    {
-        result.setData(data.getData());
-        return true;
-    }
-}
+package org.hypergraphdb.storage;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.SecondaryDatabase;
+import com.sleepycat.je.SecondaryKeyCreator;
+
+public class PlainSecondaryKeyCreator implements SecondaryKeyCreator {
+    private static final PlainSecondaryKeyCreator instance = new PlainSecondaryKeyCreator();
+
+    private PlainSecondaryKeyCreator() {
+    }
+
+    public static PlainSecondaryKeyCreator getInstance() {
+        return instance;
+    }
+
+    public boolean createSecondaryKey(SecondaryDatabase secondary,
+            DatabaseEntry key, DatabaseEntry data, DatabaseEntry result)
+            throws DatabaseException {
+        result.setData(data.getData());
+        return true;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/RAMStorageGraph.java b/src/java/org/hypergraphdb/storage/RAMStorageGraph.java
index fec20b3..f5478f6 100644
--- a/src/java/org/hypergraphdb/storage/RAMStorageGraph.java
+++ b/src/java/org/hypergraphdb/storage/RAMStorageGraph.java
@@ -5,130 +5,112 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
+package org.hypergraphdb.storage;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
 import org.hypergraphdb.HGHandle;
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.util.Pair;
-
-/**
- * <p>
- * A {@link StorageGraph} bound to a RAM map to be populated explicitly 
- * before use.
- * </p>
- * 
- * @author Borislav Iordanov
- *
- */
-public class RAMStorageGraph implements StorageGraph
-{
-    private Set<HGPersistentHandle> roots;
-    private Map<HGPersistentHandle, Object> map = new HashMap<HGPersistentHandle, Object>();
-    
-    public RAMStorageGraph()
-    {
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.util.Pair;
+
+/**
+ * <p>
+ * A {@link StorageGraph} bound to a RAM map to be populated explicitly before
+ * use.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ * 
+ */
+public class RAMStorageGraph implements StorageGraph {
+    private Set<HGPersistentHandle> roots;
+    private Map<HGPersistentHandle, Object> map = new HashMap<HGPersistentHandle, Object>();
+
+    public RAMStorageGraph() {
         this.roots = new HashSet<HGPersistentHandle>();
     }
-    
-    public RAMStorageGraph(HGPersistentHandle root)
-    {
-        this.roots = new HashSet<HGPersistentHandle>();
-        this.roots.add(root);
-    }
-    
-    public RAMStorageGraph(Set<HGPersistentHandle> roots)
-    {
-        this.roots = roots;
-    }
-    
-    public void translateHandles(Map<HGHandle, HGHandle> subst)
-    {
-        Map<HGPersistentHandle, Object> translated = new HashMap<HGPersistentHandle, Object>();
-        for (Map.Entry<HGPersistentHandle, Object> e : map.entrySet())
-        {
-            if (e.getValue() instanceof HGPersistentHandle[])
-            {
-                HGPersistentHandle[] A = (HGPersistentHandle[])e.getValue();
-                for (int i = 0; i < A.length; i++)
-                {
-                    HGHandle h = subst.get(A[i]);
-                    if (h != null)
-                        A[i] = h.getPersistent();
-                }
-            }
-            HGHandle h = subst.get(e.getKey());            
-            if (h == null)            	
-            	h = e.getKey();
-            translated.put(h.getPersistent(), e.getValue());
-        }
-        map = translated;
-    }
-    
-    public void put(HGPersistentHandle handle, HGPersistentHandle [] linkData)
-    {
-        map.put(handle, linkData);
-    }
-    
-    public void put(HGPersistentHandle handle, byte [] data)
-    {
-        map.put(handle, data);
-    }
-    
+
+    public RAMStorageGraph(HGPersistentHandle root) {
+        this.roots = new HashSet<HGPersistentHandle>();
+        this.roots.add(root);
+    }
+
+    public RAMStorageGraph(Set<HGPersistentHandle> roots) {
+        this.roots = roots;
+    }
+
+    public void translateHandles(Map<HGHandle, HGHandle> subst) {
+        Map<HGPersistentHandle, Object> translated = new HashMap<HGPersistentHandle, Object>();
+        for (Map.Entry<HGPersistentHandle, Object> e : map.entrySet()) {
+            if (e.getValue() instanceof HGPersistentHandle[]) {
+                HGPersistentHandle[] A = (HGPersistentHandle[]) e.getValue();
+                for (int i = 0; i < A.length; i++) {
+                    HGHandle h = subst.get(A[i]);
+                    if (h != null)
+                        A[i] = h.getPersistent();
+                }
+            }
+            HGHandle h = subst.get(e.getKey());
+            if (h == null)
+                h = e.getKey();
+            translated.put(h.getPersistent(), e.getValue());
+        }
+        map = translated;
+    }
+
+    public void put(HGPersistentHandle handle, HGPersistentHandle[] linkData) {
+        map.put(handle, linkData);
+    }
+
+    public void put(HGPersistentHandle handle, byte[] data) {
+        map.put(handle, data);
+    }
+
     public HGPersistentHandle store(HGPersistentHandle handle,
-                                    HGPersistentHandle[] link)
-    {
+            HGPersistentHandle[] link) {
         put(handle, link);
         return handle;
     }
 
-    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data)
-    {
+    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data) {
         put(handle, data);
         return handle;
     }
 
-    public byte[] getData(HGPersistentHandle handle)
-    {
-        return (byte[])map.get(handle);
-    }
-
-    public HGPersistentHandle[] getLink(HGPersistentHandle handle)
-    {
-        return (HGPersistentHandle[])map.get(handle);
-    }
-
-    public Set<HGPersistentHandle> getRoots()
-    {
-        return roots;
-    }
-
-    public Iterator<Pair<HGPersistentHandle, Object>> iterator()
-    {
-        return new Iterator<Pair<HGPersistentHandle, Object>>()
-        {
-            final Iterator<Map.Entry<HGPersistentHandle, Object>> i = map.entrySet().iterator();
-
-            public boolean hasNext()
-            {
-                return i.hasNext();
-            }
-
-            public Pair<HGPersistentHandle, Object> next()
-            {
-                Map.Entry<HGPersistentHandle, Object> e = i.next();
-                return new Pair<HGPersistentHandle, Object>(e.getKey(), e.getValue());
-            }
-
-            public void remove()
-            {
-                i.remove();
-            }            
-        };
-    }
-}
+    public byte[] getData(HGPersistentHandle handle) {
+        return (byte[]) map.get(handle);
+    }
+
+    public HGPersistentHandle[] getLink(HGPersistentHandle handle) {
+        return (HGPersistentHandle[]) map.get(handle);
+    }
+
+    public Set<HGPersistentHandle> getRoots() {
+        return roots;
+    }
+
+    public Iterator<Pair<HGPersistentHandle, Object>> iterator() {
+        return new Iterator<Pair<HGPersistentHandle, Object>>() {
+            final Iterator<Map.Entry<HGPersistentHandle, Object>> i = map
+                    .entrySet().iterator();
+
+            public boolean hasNext() {
+                return i.hasNext();
+            }
+
+            public Pair<HGPersistentHandle, Object> next() {
+                Map.Entry<HGPersistentHandle, Object> e = i.next();
+                return new Pair<HGPersistentHandle, Object>(e.getKey(),
+                        e.getValue());
+            }
+
+            public void remove() {
+                i.remove();
+            }
+        };
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/RefDelegateStorageGraph.java b/src/java/org/hypergraphdb/storage/RefDelegateStorageGraph.java
index e4b3712..0b3e6a1 100644
--- a/src/java/org/hypergraphdb/storage/RefDelegateStorageGraph.java
+++ b/src/java/org/hypergraphdb/storage/RefDelegateStorageGraph.java
@@ -5,58 +5,49 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.util.Pair;
-
-public class RefDelegateStorageGraph implements StorageGraph
-{
-    private Map<HGPersistentHandle, HGPersistentHandle> delegates;
-    private StorageGraph wrapped;
-    
-    public RefDelegateStorageGraph(StorageGraph wrapped, 
-                                   Map<HGPersistentHandle, HGPersistentHandle> delegates)
-    {
-        this.wrapped = wrapped;
-        this.delegates = delegates;
-    }
-    
-    public byte[] getData(HGPersistentHandle handle)
-    {
-        HGPersistentHandle del = delegates.get(handle);
-        return del != null ? wrapped.getData(del) : wrapped.getData(handle);
-    }
-
-    
-    public HGPersistentHandle[] getLink(HGPersistentHandle handle)
-    {
-        HGPersistentHandle del = delegates.get(handle);
-        return del != null ? wrapped.getLink(del) : wrapped.getLink(handle);
-    }
+package org.hypergraphdb.storage;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.util.Pair;
+
+public class RefDelegateStorageGraph implements StorageGraph {
+    private Map<HGPersistentHandle, HGPersistentHandle> delegates;
+    private StorageGraph wrapped;
+
+    public RefDelegateStorageGraph(StorageGraph wrapped,
+            Map<HGPersistentHandle, HGPersistentHandle> delegates) {
+        this.wrapped = wrapped;
+        this.delegates = delegates;
+    }
+
+    public byte[] getData(HGPersistentHandle handle) {
+        HGPersistentHandle del = delegates.get(handle);
+        return del != null ? wrapped.getData(del) : wrapped.getData(handle);
+    }
+
+    public HGPersistentHandle[] getLink(HGPersistentHandle handle) {
+        HGPersistentHandle del = delegates.get(handle);
+        return del != null ? wrapped.getLink(del) : wrapped.getLink(handle);
+    }
 
     public HGPersistentHandle store(HGPersistentHandle handle,
-                                    HGPersistentHandle[] link)
-    {
+            HGPersistentHandle[] link) {
         return wrapped.store(handle, link);
     }
 
-    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data)
-    {
+    public HGPersistentHandle store(HGPersistentHandle handle, byte[] data) {
         return wrapped.store(handle, data);
     }
 
-    public Set<HGPersistentHandle> getRoots()
-    {
-        return wrapped.getRoots();
-    }
-
-    public Iterator<Pair<HGPersistentHandle, Object>> iterator()
-    {
-        return wrapped.iterator();
-    }
-}
+    public Set<HGPersistentHandle> getRoots() {
+        return wrapped.getRoots();
+    }
+
+    public Iterator<Pair<HGPersistentHandle, Object>> iterator() {
+        return wrapped.iterator();
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/SearchResultWrapper.java b/src/java/org/hypergraphdb/storage/SearchResultWrapper.java
index 018b385..2ea4986 100644
--- a/src/java/org/hypergraphdb/storage/SearchResultWrapper.java
+++ b/src/java/org/hypergraphdb/storage/SearchResultWrapper.java
@@ -2,52 +2,42 @@ package org.hypergraphdb.storage;
 
 import org.hypergraphdb.HGSearchResult;
 
-final class SearchResultWrapper<T> implements HGSearchResult<T>
-{
-	private HGSearchResult<T> rs = null;
-	
-	public SearchResultWrapper(HGSearchResult<T> rs)
-	{
-		this.rs = rs;
-	}
-
-	public boolean hasNext()
-	{
-		return rs.hasNext();
-	}
-
-	public T next()
-	{
-		return rs.next();
-	}
-
-	public void remove()
-	{
-		rs.remove();
-	}
-
-	public void close()
-	{
-		rs.close();
-	}
-
-	public T current()
-	{
-		return rs.current();
-	}
-
-	public boolean isOrdered()
-	{
-		return rs.isOrdered();
-	}
-
-	public boolean hasPrev()
-	{
-		return rs.hasPrev();
-	}
-
-	public T prev()
-	{
-		return rs.prev();
-	}	
+final class SearchResultWrapper<T> implements HGSearchResult<T> {
+    private HGSearchResult<T> rs = null;
+
+    public SearchResultWrapper(HGSearchResult<T> rs) {
+        this.rs = rs;
+    }
+
+    public boolean hasNext() {
+        return rs.hasNext();
+    }
+
+    public T next() {
+        return rs.next();
+    }
+
+    public void remove() {
+        rs.remove();
+    }
+
+    public void close() {
+        rs.close();
+    }
+
+    public T current() {
+        return rs.current();
+    }
+
+    public boolean isOrdered() {
+        return rs.isOrdered();
+    }
+
+    public boolean hasPrev() {
+        return rs.hasPrev();
+    }
+
+    public T prev() {
+        return rs.prev();
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/SingleKeyResultSet.java b/src/java/org/hypergraphdb/storage/SingleKeyResultSet.java
index eb4f9fc..6c234c1 100644
--- a/src/java/org/hypergraphdb/storage/SingleKeyResultSet.java
+++ b/src/java/org/hypergraphdb/storage/SingleKeyResultSet.java
@@ -5,76 +5,66 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.transaction.BDBTxCursor;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-
-/**
- * <p>
- * Implements a BerkeleyDB <code>Cursor</code> based result set that iterates over
- * all duplicates of a given key.
- * </p>
- * 
- * @author Borislav Iordanov
- */
-public class SingleKeyResultSet<T> extends IndexResultSet<T>
-{
-	private boolean ordered = false;
-    
-    public SingleKeyResultSet(BDBTxCursor cursor, DatabaseEntry key, ByteArrayConverter<T> converter)
-    {
-        super(cursor, key, converter);
-        try
-        {
-        	ordered = cursor.cursor().getDatabase().getConfig().getSortedDuplicates();
-        }
-        catch (Throwable t)
-        {
-        	throw new HGException(t);
-        }
-    }   
-    
-    protected T advance()
-    {
-        try
-        {
-            OperationStatus status = cursor.cursor().getNextDup(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }            
-    }
-    
-    protected T back()
-    {
-        try
-        {
-            OperationStatus status = cursor.cursor().getPrevDup(key, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(data.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }                        
-    }
-    
-    public boolean isOrdered()
-    {
-    	return ordered;
-    }
-}
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.transaction.BDBTxCursor;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+
+/**
+ * <p>
+ * Implements a BerkeleyDB <code>Cursor</code> based result set that iterates
+ * over all duplicates of a given key.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public class SingleKeyResultSet<T> extends IndexResultSet<T> {
+    private boolean ordered = false;
+
+    public SingleKeyResultSet(BDBTxCursor cursor, DatabaseEntry key,
+            ByteArrayConverter<T> converter) {
+        super(cursor, key, converter);
+        try {
+            ordered = cursor.cursor().getDatabase().getConfig()
+                    .getSortedDuplicates();
+        } catch (Throwable t) {
+            throw new HGException(t);
+        }
+    }
+
+    protected T advance() {
+        try {
+            OperationStatus status = cursor.cursor().getNextDup(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    protected T back() {
+        try {
+            OperationStatus status = cursor.cursor().getPrevDup(key, data,
+                    LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(data.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    public boolean isOrdered() {
+        return ordered;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/SingleValueResultSet.java b/src/java/org/hypergraphdb/storage/SingleValueResultSet.java
index fc83654..4c0c451 100644
--- a/src/java/org/hypergraphdb/storage/SingleValueResultSet.java
+++ b/src/java/org/hypergraphdb/storage/SingleValueResultSet.java
@@ -5,132 +5,113 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.transaction.BDBTxCursor;
-import org.hypergraphdb.util.HGUtils;
-
-import com.sleepycat.db.SecondaryCursor;
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.LockMode;
-import com.sleepycat.db.OperationStatus;
-
-/**
- * <p>A result set based on a BerkeleyDB secondary cursor. That is, when a BerkeleyDB has
- * a secondary DB, it is possible to use the keys of the secondary DB to get primary
- * key and data of the primary DB. This result set returns primary keys based on secondary
- * keys and it ignores the data (which usually will simply be the same thing as the secondary key).
- * </p>
- * 
- * @author Borislav Iordanov
- */
-public class SingleValueResultSet<T> extends IndexResultSet<T>
-{
-    private DatabaseEntry pkey = new DatabaseEntry();
-    
-    public SingleValueResultSet(BDBTxCursor cursor, DatabaseEntry keyIn, ByteArrayConverter<T> converter)
-    {
-        //
-    	// The following is bit hacky because we want to avoid some of the default behavior
-    	// of the super constructor, which is incorrect when the "values" we are interested in 
-    	// are the DB's primary keys. So we duplicate its bebavior and override instantiation
-    	// of the current value.
-        this.converter = converter;
-        this.cursor = cursor;
+package org.hypergraphdb.storage;
+
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.transaction.BDBTxCursor;
+import org.hypergraphdb.util.HGUtils;
+
+import com.sleepycat.je.DatabaseEntry;
+import com.sleepycat.je.LockMode;
+import com.sleepycat.je.OperationStatus;
+import com.sleepycat.je.SecondaryCursor;
+
+/**
+ * <p>
+ * A result set based on a BerkeleyDB secondary cursor. That is, when a
+ * BerkeleyDB has a secondary DB, it is possible to use the keys of the
+ * secondary DB to get primary key and data of the primary DB. This result set
+ * returns primary keys based on secondary keys and it ignores the data (which
+ * usually will simply be the same thing as the secondary key).
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public class SingleValueResultSet<T> extends IndexResultSet<T> {
+    private DatabaseEntry pkey = new DatabaseEntry();
+
+    public SingleValueResultSet(BDBTxCursor cursor, DatabaseEntry keyIn,
+            ByteArrayConverter<T> converter) {
+        //
+        // The following is bit hacky because we want to avoid some of the
+        // default behavior
+        // of the super constructor, which is incorrect when the "values" we are
+        // interested in
+        // are the DB's primary keys. So we duplicate its bebavior and override
+        // instantiation
+        // of the current value.
+        this.converter = converter;
+        this.cursor = cursor;
         this.key = new DatabaseEntry();
         this.data = new DatabaseEntry();
-        // TODO: for fixed size key and data,we should actually reuse the buffers, but
-        // this has to be passed somehow as a configuration parameter to the HGIndex
-        // implementation and down to result sets. It's a worthwhile optimization.
-        this.key.setReuseBuffer(false);
-        this.data.setReuseBuffer(false);
-        if (keyIn != null)
-        	assignData(key, keyIn.getData());        
-	    try
-	    {
-	        ((SecondaryCursor)cursor.cursor()).getCurrent(key, pkey, data, LockMode.DEFAULT);
-	        next = converter.fromByteArray(pkey.getData());
-	        lookahead = 1;
-	    }
-	    catch (Throwable t)
-	    {
-	        throw new HGException(t);
-	    }       
-        
-    }
-    
-    
-    protected T advance()
-    {
-        try
-        {
-            OperationStatus status = ((SecondaryCursor)cursor.cursor()).getNextDup(key, pkey, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(pkey.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }     
-    }
-
-    protected T back()
-    {
-        try
-        {
-            OperationStatus status = ((SecondaryCursor)cursor.cursor()).getPrevDup(key, pkey, data, LockMode.DEFAULT);
-            if (status == OperationStatus.SUCCESS)
-                return converter.fromByteArray(pkey.getData());
-            else
-                return null;
-        }
-        catch (Throwable t)
-        {
-            closeNoException();
-            throw new HGException(t);
-        }                        
-    }
-    
-    public GotoResult goTo(T value, boolean exactMatch)
-    {
-    	byte [] B = converter.toByteArray(value);
-    	assignData(pkey, B);
-    	try
-    	{
-    		if (exactMatch)
-    		{
-    			if (((SecondaryCursor)cursor.cursor()).getSearchBoth(key, pkey, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-    			{
-    				positionToCurrent(pkey.getData());
-    				return GotoResult.found; 
-    			}
-    			else
-    				return GotoResult.nothing;
-    		}
-    		else
-    		{
-    			if (((SecondaryCursor)cursor.cursor()).getSearchBothRange(key, pkey, data, LockMode.DEFAULT) == OperationStatus.SUCCESS)
-    			{
-    				positionToCurrent(pkey.getData());
-    				return HGUtils.eq(B, pkey.getData()) ? GotoResult.found : GotoResult.close;
-    			}
-    			else
-    				return GotoResult.nothing;     			
-    		}
-    	}
-    	catch (Throwable t)
-    	{
-    		closeNoException();
-    		throw new HGException(t);
-    	}
-    }
-    
-    public boolean isOrdered()
-    {
-    	return false;
-    }
-}
+        if (keyIn != null)
+            assignData(key, keyIn.getData());
+        try {
+            ((SecondaryCursor) cursor.cursor()).getCurrent(key, pkey, data,
+                    LockMode.DEFAULT);
+            next = converter.fromByteArray(pkey.getData());
+            lookahead = 1;
+        } catch (Throwable t) {
+            throw new HGException(t);
+        }
+
+    }
+
+    protected T advance() {
+        try {
+            OperationStatus status = ((SecondaryCursor) cursor.cursor())
+                    .getNextDup(key, pkey, data, LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(pkey.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    protected T back() {
+        try {
+            OperationStatus status = ((SecondaryCursor) cursor.cursor())
+                    .getPrevDup(key, pkey, data, LockMode.DEFAULT);
+            if (status == OperationStatus.SUCCESS)
+                return converter.fromByteArray(pkey.getData());
+            else
+                return null;
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    public GotoResult goTo(T value, boolean exactMatch) {
+        byte[] B = converter.toByteArray(value);
+        assignData(pkey, B);
+        try {
+            if (exactMatch) {
+                if (((SecondaryCursor) cursor.cursor()).getSearchBoth(key,
+                        pkey, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
+                    positionToCurrent(pkey.getData());
+                    return GotoResult.found;
+                } else
+                    return GotoResult.nothing;
+            } else {
+                if (((SecondaryCursor) cursor.cursor()).getSearchBothRange(key,
+                        pkey, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
+                    positionToCurrent(pkey.getData());
+                    return HGUtils.eq(B, pkey.getData()) ? GotoResult.found
+                            : GotoResult.close;
+                } else
+                    return GotoResult.nothing;
+            }
+        } catch (Throwable t) {
+            closeNoException();
+            throw new HGException(t);
+        }
+    }
+
+    public boolean isOrdered() {
+        return false;
+    }
+}
diff --git a/src/java/org/hypergraphdb/storage/StorageBasedIncidenceSet.java b/src/java/org/hypergraphdb/storage/StorageBasedIncidenceSet.java
index 138f02d..0d915a0 100644
--- a/src/java/org/hypergraphdb/storage/StorageBasedIncidenceSet.java
+++ b/src/java/org/hypergraphdb/storage/StorageBasedIncidenceSet.java
@@ -8,220 +8,179 @@ import java.util.SortedSet;
 
 import org.hypergraphdb.HGHandle;
 import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.HyperGraph;
 import org.hypergraphdb.HGRandomAccessResult.GotoResult;
+import org.hypergraphdb.HyperGraph;
 import org.hypergraphdb.util.HGSortedSet;
 
-public class StorageBasedIncidenceSet implements HGSortedSet<HGHandle>
-{
+public class StorageBasedIncidenceSet implements HGSortedSet<HGHandle> {
     private HGHandle atom;
     private HyperGraph graph;
 
-    public StorageBasedIncidenceSet(HGHandle atom, HyperGraph graph)
-    {
+    public StorageBasedIncidenceSet(HGHandle atom, HyperGraph graph) {
         this.atom = atom;
         this.graph = graph;
     }
 
     @SuppressWarnings("unchecked")
-    public HGRandomAccessResult<HGHandle> getSearchResult()
-    {
-        return (HGRandomAccessResult<HGHandle>)(HGRandomAccessResult<?>)
-            graph.getStore().getIncidenceResultSet(graph.getPersistentHandle(atom));
+    public HGRandomAccessResult<HGHandle> getSearchResult() {
+        return (HGRandomAccessResult<HGHandle>) (HGRandomAccessResult<?>) graph
+                .getStore().getIncidenceResultSet(
+                        graph.getPersistentHandle(atom));
     }
 
     @SuppressWarnings("unchecked")
-    public Comparator<? super HGHandle> comparator()
-    {
-        return new Comparator()
-        {
-            public int compare(Object x, Object y)
-            {
-                return ((Comparable)x).compareTo(y);
+    public Comparator<? super HGHandle> comparator() {
+        return new Comparator() {
+            public int compare(Object x, Object y) {
+                return ((Comparable) x).compareTo(y);
             }
         };
     }
 
-    public HGHandle first()
-    {
+    public HGHandle first() {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
+        try {
             if (!rs.hasNext())
                 throw new NoSuchElementException();
             return rs.next();
-        }
-        finally
-        {
+        } finally {
             rs.close();
         }
     }
 
-    public SortedSet<HGHandle> headSet(HGHandle toElement)
-    {
+    public SortedSet<HGHandle> headSet(HGHandle toElement) {
         throw new UnsupportedOperationException();
     }
 
-    public HGHandle last()
-    {
+    public HGHandle last() {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
-            rs.goAfterLast();            
+        try {
+            rs.goAfterLast();
             if (!rs.hasPrev())
                 throw new NoSuchElementException();
             return rs.prev();
-        }
-        finally
-        {
+        } finally {
             rs.close();
         }
     }
 
-    public SortedSet<HGHandle> subSet(HGHandle fromElement, HGHandle toElement)
-    {
+    public SortedSet<HGHandle> subSet(HGHandle fromElement, HGHandle toElement) {
         throw new UnsupportedOperationException();
     }
 
-    public SortedSet<HGHandle> tailSet(HGHandle fromElement)
-    {
+    public SortedSet<HGHandle> tailSet(HGHandle fromElement) {
         throw new UnsupportedOperationException();
     }
 
-    public boolean add(HGHandle e)
-    {
-        if (contains((HGHandle)e))
+    public boolean add(HGHandle e) {
+        if (contains((HGHandle) e))
             return false;
-        graph.getStore().addIncidenceLink(graph.getPersistentHandle(atom), graph.getPersistentHandle(e));
-        return true;        
+        graph.getStore().addIncidenceLink(graph.getPersistentHandle(atom),
+                graph.getPersistentHandle(e));
+        return true;
     }
 
-    public boolean addAll(Collection<? extends HGHandle> c)
-    {
+    public boolean addAll(Collection<? extends HGHandle> c) {
         boolean modified = false;
         for (HGHandle x : c)
             modified = modified || add(x);
         return modified;
     }
 
-    public void clear()
-    {
+    public void clear() {
         graph.getStore().removeIncidenceSet(graph.getPersistentHandle(atom));
     }
 
-    public boolean contains(Object o)
-    {
+    public boolean contains(Object o) {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
-            return rs.goTo((HGHandle)o, true) == GotoResult.found;
-        }
-        finally
-        {
+        try {
+            return rs.goTo((HGHandle) o, true) == GotoResult.found;
+        } finally {
             rs.close();
         }
     }
 
     @SuppressWarnings("unchecked")
-    public boolean containsAll(Collection<?> c)
-    {
+    public boolean containsAll(Collection<?> c) {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try 
-        { 
-            for (HGHandle x : (Collection<HGHandle>)c)            
+        try {
+            for (HGHandle x : (Collection<HGHandle>) c)
                 if (rs.goTo(x, true) != HGRandomAccessResult.GotoResult.found)
                     return false;
             return true;
-        }
-        finally
-        {
+        } finally {
             rs.close();
-        }        
+        }
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
+        try {
             return !rs.hasNext();
-        }
-        finally
-        {
+        } finally {
             rs.close();
         }
     }
 
-    public Iterator<HGHandle> iterator()
-    {
-        throw new UnsupportedOperationException("Use getSearchResult and make sure you close it.");
+    public Iterator<HGHandle> iterator() {
+        throw new UnsupportedOperationException(
+                "Use getSearchResult and make sure you close it.");
     }
 
-    public boolean remove(Object o)
-    {
-        if (contains(o))
-        {
-            graph.getStore().removeIncidenceLink(graph.getPersistentHandle(atom), 
-                        graph.getPersistentHandle((HGHandle)o));
+    public boolean remove(Object o) {
+        if (contains(o)) {
+            graph.getStore().removeIncidenceLink(
+                    graph.getPersistentHandle(atom),
+                    graph.getPersistentHandle((HGHandle) o));
             return true;
-        }
-        else
+        } else
             return false;
     }
 
-    public boolean removeAll(Collection<?> c)
-    {
+    public boolean removeAll(Collection<?> c) {
         boolean modified = false;
         for (Object x : c)
             modified = modified || remove(x);
         return modified;
     }
 
-    public boolean retainAll(Collection<?> c)
-    {
+    public boolean retainAll(Collection<?> c) {
         throw new UnsupportedOperationException();
     }
 
-    public int size()
-    {
-        return (int)graph.getStore().getIncidenceSetCardinality(graph.getPersistentHandle(atom));
+    public int size() {
+        return (int) graph.getStore().getIncidenceSetCardinality(
+                graph.getPersistentHandle(atom));
     }
 
-    public Object[] toArray()
-    {
+    public Object[] toArray() {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
+        try {
             int size = size();
-            Object [] a = new Object[size];
+            Object[] a = new Object[size];
             for (int i = 0; i < size; i++)
                 a[i] = rs.next();
             return a;
-        }
-        finally
-        {
+        } finally {
             rs.close();
         }
     }
 
     @SuppressWarnings("unchecked")
-    public <T> T[] toArray(T[] a)
-    {
+    public <T> T[] toArray(T[] a) {
         HGRandomAccessResult<HGHandle> rs = getSearchResult();
-        try
-        {
+        try {
             int size = size();
             if (a.length < size)
-                a = (T[])java.lang.reflect.Array
-            .newInstance(a.getClass().getComponentType(), size);
+                a = (T[]) java.lang.reflect.Array.newInstance(a.getClass()
+                        .getComponentType(), size);
             for (int i = 0; i < size; i++)
-                a[i] = (T)rs.next();
+                a[i] = (T) rs.next();
             if (a.length > size)
                 a[size] = null;
             return a;
-        }
-        finally
-        {
+        } finally {
             rs.close();
-        }    }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/java/org/hypergraphdb/storage/StorageGraph.java b/src/java/org/hypergraphdb/storage/StorageGraph.java
index bad911f..990b9cf 100644
--- a/src/java/org/hypergraphdb/storage/StorageGraph.java
+++ b/src/java/org/hypergraphdb/storage/StorageGraph.java
@@ -5,40 +5,48 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.storage;
-
-import java.util.Iterator;
-import java.util.Set;
-
-import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.util.Pair;
-
-/**
- * <p>
- * Represents a storage layout graph. Implementations of this interface
- * could be RAM based, disk based or a mix of both. A storage layout graph
- * is represented roughly as the main <code>HGStore</code>  - a 
- * <code>HGPersistentHandle</code> keyed map whose values are either 
- * <code>HGPersistentHandle</code> arrays or byte buffers.
- * </p>
- * <p>
- * In addition, a <code>StorageGraph</code> has a set of designated roots, or
- * starting points to the graph. The intent
- * is for <code>StorageGraph</code> instances to represent a portion of the
- * full disk storage for a given atom or a set of atoms, for example for 
- * purposes of network communication.  
- * </p> 
- * @author Borislav Iordanov
- */
-public interface StorageGraph extends Iterable<Pair<HGPersistentHandle, Object>>
-{
-    /**
-     * <p>Return the set of root handles for this storage sub-graph.</p>
-     */
-    Set<HGPersistentHandle> getRoots();
-    HGPersistentHandle [] getLink(HGPersistentHandle handle);
-    HGPersistentHandle store(HGPersistentHandle handle, HGPersistentHandle [] link);
-    byte [] getData(HGPersistentHandle handle);
-    HGPersistentHandle store(HGPersistentHandle handle, byte [] data);
-    Iterator<Pair<HGPersistentHandle, Object>> iterator();
-}
+package org.hypergraphdb.storage;
+
+import java.util.Iterator;
+import java.util.Set;
+
+import org.hypergraphdb.HGPersistentHandle;
+import org.hypergraphdb.util.Pair;
+
+/**
+ * <p>
+ * Represents a storage layout graph. Implementations of this interface could be
+ * RAM based, disk based or a mix of both. A storage layout graph is represented
+ * roughly as the main <code>HGStore</code> - a <code>HGPersistentHandle</code>
+ * keyed map whose values are either <code>HGPersistentHandle</code> arrays or
+ * byte buffers.
+ * </p>
+ * <p>
+ * In addition, a <code>StorageGraph</code> has a set of designated roots, or
+ * starting points to the graph. The intent is for <code>StorageGraph</code>
+ * instances to represent a portion of the full disk storage for a given atom or
+ * a set of atoms, for example for purposes of network communication.
+ * </p>
+ * 
+ * @author Borislav Iordanov
+ */
+public interface StorageGraph extends
+        Iterable<Pair<HGPersistentHandle, Object>> {
+    /**
+     * <p>
+     * Return the set of root handles for this storage sub-graph.
+     * </p>
+     */
+    Set<HGPersistentHandle> getRoots();
+
+    HGPersistentHandle[] getLink(HGPersistentHandle handle);
+
+    HGPersistentHandle store(HGPersistentHandle handle,
+            HGPersistentHandle[] link);
+
+    byte[] getData(HGPersistentHandle handle);
+
+    HGPersistentHandle store(HGPersistentHandle handle, byte[] data);
+
+    Iterator<Pair<HGPersistentHandle, Object>> iterator();
+}
diff --git a/src/java/org/hypergraphdb/transaction/BDBTxCursor.java b/src/java/org/hypergraphdb/transaction/BDBTxCursor.java
index 074d06f..b9db749 100644
--- a/src/java/org/hypergraphdb/transaction/BDBTxCursor.java
+++ b/src/java/org/hypergraphdb/transaction/BDBTxCursor.java
@@ -7,11 +7,11 @@
  */
 package org.hypergraphdb.transaction;
 
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.util.CloseMe;
-
-import com.sleepycat.db.Cursor;
-import com.sleepycat.db.DatabaseException;
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.util.CloseMe;
+
+import com.sleepycat.je.Cursor;
+import com.sleepycat.je.DatabaseException;
 
 public final class BDBTxCursor implements CloseMe
 {
diff --git a/src/java/org/hypergraphdb/transaction/BDBTxLock.java b/src/java/org/hypergraphdb/transaction/BDBTxLock.java
deleted file mode 100644
index dce82b9..0000000
--- a/src/java/org/hypergraphdb/transaction/BDBTxLock.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/* 
- * This file is part of the HyperGraphDB source distribution. This is copyrighted 
- * software. For permitted uses, licensing options and redistribution, please see  
- * the LicensingInformation file at the root level of the distribution.  
- * 
- * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
- */
-package org.hypergraphdb.transaction;
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReadWriteLock;
-
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.HyperGraph;
-
-import com.sleepycat.db.DatabaseEntry;
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.Environment;
-import com.sleepycat.db.LockNotGrantedException;
-import com.sleepycat.db.LockRequestMode;
-
-/**
- * 
- * <p>
- * A <code>ReadWriteLock</code> implementation backed by the BerkeleyDB locking
- * mechanism. This implementation uses the current HGDB transaction as the BDB locker.
- * Only the <code>lock()</code>, <code>unlock()</code> and <code>tryLock()</code>
- * methods are actually supported for now. 
- * </p>
- *
- * @author Borislav Iordanov
- *
- */
-public class BDBTxLock implements ReadWriteLock
-{
-	private HyperGraph graph;
-	private DatabaseEntry objectId;
-	private BDBReadLock readLock = new BDBReadLock();
-	private BDBWriteLock writeLock = new BDBWriteLock();	
-	
-	private int getLockerId()
-	{
-		try
-		{
-			return ((TransactionBDBImpl)graph.getTransactionManager().getContext().getCurrent().getStorageTransaction()).getBDBTransaction().getId();
-		}
-		catch (DatabaseException ex)
-		{
-			throw new HGException(ex);
-		}
-	}
-
-	private Environment getEnv()
-	{
-		return ((TransactionBDBImpl)graph.getTransactionManager().getContext().getCurrent().getStorageTransaction()).getBDBEnvironment();		
-	}
-	
-	private class BDBReadLock implements Lock
-	{
-		com.sleepycat.db.Lock lock = null;
-		ThreadLocal<Integer> readCount = new ThreadLocal<Integer>() {
-		    protected Integer initialValue() { return 0; }
-		};
-		
-		BDBReadLock()
-		{								
-		}
-		
-		public synchronized void lock()
-		{
-			try
-			{
-				if (readCount.get() == 0)
-					lock = getEnv().getLock(getLockerId(), false, objectId, LockRequestMode.READ);				
-				readCount.set(readCount.get() + 1);				
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}
-		}
-
-		public void lockInterruptibly() throws InterruptedException
-		{
-			throw new UnsupportedOperationException();
-		}
-
-		public Condition newCondition()
-		{
-			throw new UnsupportedOperationException();
-		}
-
-		public synchronized boolean tryLock()
-		{
-			try
-			{
-				if (readCount.get() == 0)
-					lock = getEnv().getLock(getLockerId(), true, objectId, LockRequestMode.READ);
-				if (lock != null)
-				{
-					readCount.set(readCount.get() + 1);
-					return true;
-				}
-				else
-					return false;
-			}
-			catch (LockNotGrantedException le)
-			{
-				return false;
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}
-		}
-
-		public boolean tryLock(long time, TimeUnit unit) throws InterruptedException
-		{
-			throw new UnsupportedOperationException();			
-		}
-
-		public synchronized void unlock()
-		{
-			try
-			{
-				if (lock != null)
-				{
-					int newcnt = readCount.get() - 1;
-					if (newcnt < 0)
-						throw new IllegalStateException("Lock already released.");
-					else if (newcnt == 0)
-					{
-						getEnv().putLock(lock);					
-						lock = null;
-					}					
-					readCount.set(newcnt);					
-				}
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}			
-		}		
-	}
-	
-	private class BDBWriteLock implements Lock
-	{
-		com.sleepycat.db.Lock lock;
-		ThreadLocal<Integer> writeCount = new ThreadLocal<Integer>() {
-		    protected Integer initialValue() { return 0; }
-		};
-		
-		BDBWriteLock()
-		{
-			writeCount.set(new Integer(0));				
-		}
-		
-		public void lock()
-		{
-			try
-			{				
-				if (writeCount.get() == 0)
-					lock = getEnv().getLock(getLockerId(), false, objectId, LockRequestMode.WRITE);
-				writeCount.set(writeCount.get() + 1);
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}
-		}
-
-		public void lockInterruptibly() throws InterruptedException
-		{
-			throw new UnsupportedOperationException();
-		}
-
-		public Condition newCondition()
-		{
-			throw new UnsupportedOperationException();
-		}
-
-		public boolean tryLock()
-		{
-			try
-			{
-				if (writeCount.get() == 0)
-					lock = getEnv().getLock(getLockerId(), true, objectId, LockRequestMode.WRITE);
-				if (lock != null)
-				{					
-					writeCount.set(writeCount.get() + 1);
-					return true;
-				}
-				else
-					return false;
-			}
-			catch (LockNotGrantedException le)
-			{
-				return false;
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}
-		}
-
-		public boolean tryLock(long time, TimeUnit unit) throws InterruptedException
-		{
-			throw new UnsupportedOperationException();			
-		}
-
-		public void unlock()
-		{
-			try
-			{
-				int newcnt = writeCount.get() - 1;
-				if (newcnt < 0)
-					throw new IllegalStateException("Lock already released.");
-				else if (newcnt == 0)
-				{
-					getEnv().putLock(lock);
-					lock = null;
-				}
-				writeCount.set(newcnt);
-			}
-			catch (DatabaseException ex)
-			{
-				throw new HGException(ex);
-			}			
-		}		
-	}
-	
-	public BDBTxLock(HyperGraph graph, byte [] objectId)
-	{
-		this(graph, new DatabaseEntry(objectId));
-	}
-	
-	public BDBTxLock(HyperGraph graph, DatabaseEntry objectId)
-	{
-		this.graph = graph;
-		this.objectId = new DatabaseEntry();
-		byte [] tmp = new byte[objectId.getData().length];
-		System.arraycopy(objectId.getData(), 0, tmp, 0, tmp.length);
-		this.objectId = new DatabaseEntry(tmp);
-	}
-	
-	public Lock readLock()
-	{
-		return readLock;
-	}
-
-	public Lock writeLock()
-	{
-		return writeLock;
-	}
-	
-	public HyperGraph getGraph()
-	{
-		return graph;
-	}
-	
-	public byte [] getObjectId()
-	{
-		return objectId.getData();
-	}
-}
diff --git a/src/java/org/hypergraphdb/transaction/HGTransactionManager.java b/src/java/org/hypergraphdb/transaction/HGTransactionManager.java
index 7881261..b7cfc47 100644
--- a/src/java/org/hypergraphdb/transaction/HGTransactionManager.java
+++ b/src/java/org/hypergraphdb/transaction/HGTransactionManager.java
@@ -10,9 +10,11 @@ package org.hypergraphdb.transaction;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReentrantLock;
-import org.hypergraphdb.HGException;
+
+import org.hypergraphdb.HGException;
 import org.hypergraphdb.HyperGraph;
-import com.sleepycat.db.DeadlockException;
+
+import com.sleepycat.je.DeadlockException;
 
 /**
  * 
diff --git a/src/java/org/hypergraphdb/transaction/TransactionBDBImpl.java b/src/java/org/hypergraphdb/transaction/TransactionBDBImpl.java
index f37e155..01a0980 100644
--- a/src/java/org/hypergraphdb/transaction/TransactionBDBImpl.java
+++ b/src/java/org/hypergraphdb/transaction/TransactionBDBImpl.java
@@ -11,10 +11,10 @@ package org.hypergraphdb.transaction;
 import java.util.HashSet;
 import java.util.Set;
 
-import com.sleepycat.db.Cursor;
-import com.sleepycat.db.DatabaseException;
-import com.sleepycat.db.Environment;
-import com.sleepycat.db.Transaction;
+import com.sleepycat.je.Cursor;
+import com.sleepycat.je.DatabaseException;
+import com.sleepycat.je.Environment;
+import com.sleepycat.je.Transaction;
 
 public class TransactionBDBImpl implements HGStorageTransaction
 {
diff --git a/src/java/org/hypergraphdb/transaction/TxMonitor.java b/src/java/org/hypergraphdb/transaction/TxMonitor.java
index d5da9eb..843e187 100644
--- a/src/java/org/hypergraphdb/transaction/TxMonitor.java
+++ b/src/java/org/hypergraphdb/transaction/TxMonitor.java
@@ -5,59 +5,61 @@
  * 
  * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
  */
-package org.hypergraphdb.transaction;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-public class TxMonitor
-{
-	public static class Info
-	{
-		int id = 0;
-		String threadName = null;
-		String beginTrace = null;
-		String endTrace = null;
-	}
-	
-	public Map<Integer, Info> txMap = Collections.synchronizedMap(new HashMap<Integer, Info>());
-	
-	public void transactionCreated(HGTransaction tx)
-	{
-		try
-		{
-			Info txInfo = new Info();
-			txInfo.id = ((TransactionBDBImpl)tx.getStorageTransaction()).getBDBTransaction().getId();
-			txInfo.threadName = Thread.currentThread().getName();
-			StringBuffer b = new StringBuffer();
-			for (StackTraceElement el : Thread.currentThread().getStackTrace())
-				{ b.append(el.toString()); b.append("\n"); }
-			txInfo.beginTrace = b.toString();
-			txMap.put(txInfo.id, txInfo);
-		}
-		catch (Throwable t) { t.printStackTrace(); }
-	}
-	
-	public void transactionFinished(HGTransaction tx)
-	{
-		try
-		{
-			int id;
-			id = ((TransactionBDBImpl)tx.getStorageTransaction()).getBDBTransaction().getId();
-			txMap.remove(id);
-			if ( 1 == 1) return;
-			Info txInfo = txMap.get(id);
-			if (txInfo == null)
-				throw new NullPointerException("No transaction with ID " + id + " was recorded to start.");
-			StringBuffer b = new StringBuffer();
-			for (StackTraceElement el : Thread.currentThread().getStackTrace())
-				{ b.append(el.toString()); b.append("\n"); }
-			txInfo.endTrace = b.toString();
-		}
-		catch (Throwable t)
-		{
-			t.printStackTrace();
-		}
-	}	
-}
+package org.hypergraphdb.transaction;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class TxMonitor {
+    public static class Info {
+        long id = 0;
+        String threadName = null;
+        String beginTrace = null;
+        String endTrace = null;
+    }
+
+    public Map<Long, Info> txMap = Collections
+            .synchronizedMap(new HashMap<Long, Info>());
+
+    public void transactionCreated(HGTransaction tx) {
+        try {
+            Info txInfo = new Info();
+            txInfo.id = ((TransactionBDBImpl) tx.getStorageTransaction())
+                    .getBDBTransaction().getId();
+            txInfo.threadName = Thread.currentThread().getName();
+            StringBuffer b = new StringBuffer();
+            for (StackTraceElement el : Thread.currentThread().getStackTrace()) {
+                b.append(el.toString());
+                b.append("\n");
+            }
+            txInfo.beginTrace = b.toString();
+            txMap.put(txInfo.id, txInfo);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+    }
+
+    public void transactionFinished(HGTransaction tx) {
+        try {
+            long id;
+            id = ((TransactionBDBImpl) tx.getStorageTransaction())
+                    .getBDBTransaction().getId();
+            txMap.remove(id);
+            if (1 == 1)
+                return;
+            Info txInfo = txMap.get(id);
+            if (txInfo == null)
+                throw new NullPointerException("No transaction with ID " + id
+                        + " was recorded to start.");
+            StringBuffer b = new StringBuffer();
+            for (StackTraceElement el : Thread.currentThread().getStackTrace()) {
+                b.append(el.toString());
+                b.append("\n");
+            }
+            txInfo.endTrace = b.toString();
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+    }
+}
diff --git a/src/java/org/hypergraphdb/util/HGLock.java b/src/java/org/hypergraphdb/util/HGLock.java
deleted file mode 100644
index e4b4201..0000000
--- a/src/java/org/hypergraphdb/util/HGLock.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/* 
- * This file is part of the HyperGraphDB source distribution. This is copyrighted 
- * software. For permitted uses, licensing options and redistribution, please see  
- * the LicensingInformation file at the root level of the distribution.  
- * 
- * Copyright (c) 2005-2010 Kobrix Software, Inc.  All rights reserved. 
- */
-package org.hypergraphdb.util;
-
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-import org.hypergraphdb.HyperGraph;
-import org.hypergraphdb.transaction.BDBTxLock;
-import org.hypergraphdb.transaction.HGTransaction;
-import org.hypergraphdb.transaction.TransactionBDBImpl;
-
-/**
- * 
- * <p>
- * An implementation of <code>ReadWriteLock</code> that will use the currently
- * active database transaction if there is one (through <code>BDBTxLock</code>) 
- * or a default <code>ReentrantReadWriteLock</code> if there is no current transaction.
- * The implementation is useful for runtime data structures that need protection
- * from concurrent access and that may or may not participate in a database
- * transaction. 
- * </p>
- *
- * @author Borislav Iordanov
- *
- */
-public class HGLock implements ReadWriteLock
-{
-	private ReentrantReadWriteLock defaultLock = null;
-	private BDBTxLock txLock = null;
-	
-	ReadWriteLock getApplicableLock()
-	{
-		HGTransaction tx = txLock.getGraph().getTransactionManager().getContext().getCurrent(); 
-		if (tx == null || ! (tx.getStorageTransaction() instanceof TransactionBDBImpl))
-		{
-			if (defaultLock == null)
-				defaultLock = new ReentrantReadWriteLock();
-			return defaultLock;
-		}
-		else
-			return txLock;
-	}
-	
-	public HGLock(HyperGraph graph, byte [] objectId)
-	{
-		txLock = new BDBTxLock(graph, objectId);
-	}
-	
-	public Lock readLock()
-	{
-		return getApplicableLock().readLock();
-	}
-
-	public Lock writeLock()
-	{
-		return getApplicableLock().writeLock();
-	}
-}
diff --git a/src/java/org/hypergraphdb/util/HGUtils.java b/src/java/org/hypergraphdb/util/HGUtils.java
index 033a269..54cd509 100644
--- a/src/java/org/hypergraphdb/util/HGUtils.java
+++ b/src/java/org/hypergraphdb/util/HGUtils.java
@@ -10,8 +10,8 @@ package org.hypergraphdb.util;
 import java.beans.BeanInfo;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
-import java.io.File;
-import java.io.PrintStream;
+import java.io.File;
+import java.io.PrintStream;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
@@ -19,20 +19,20 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
-
+
 import org.hypergraphdb.HGEnvironment;
-import org.hypergraphdb.HGException;
-import org.hypergraphdb.HGHandle;
-import org.hypergraphdb.HGLink;
+import org.hypergraphdb.HGException;
+import org.hypergraphdb.HGHandle;
+import org.hypergraphdb.HGLink;
 import org.hypergraphdb.HGPersistentHandle;
-import org.hypergraphdb.HGQuery;
-import org.hypergraphdb.HGRandomAccessResult;
-import org.hypergraphdb.HGSearchResult;
-import org.hypergraphdb.HyperGraph;
-import org.hypergraphdb.HGRandomAccessResult.GotoResult;
+import org.hypergraphdb.HGQuery;
+import org.hypergraphdb.HGRandomAccessResult;
+import org.hypergraphdb.HGRandomAccessResult.GotoResult;
+import org.hypergraphdb.HGSearchResult;
+import org.hypergraphdb.HyperGraph;
 import org.hypergraphdb.transaction.TransactionConflictException;
 
-import com.sleepycat.db.DeadlockException;
+import com.sleepycat.je.DeadlockException;
 
 /**
  * 
diff --git a/src/java/org/hypergraphdb/util/SimpleStack.java b/src/java/org/hypergraphdb/util/SimpleStack.java
index d5853fe..8bfb6fe 100644
--- a/src/java/org/hypergraphdb/util/SimpleStack.java
+++ b/src/java/org/hypergraphdb/util/SimpleStack.java
@@ -8,7 +8,7 @@
 package org.hypergraphdb.util;
 
 import java.util.Iterator;
-import java.util.NoSuchElementException;
+import java.util.NoSuchElementException;
 
 /**
  * <p>
@@ -91,13 +91,11 @@ public class SimpleStack<T> implements Iterable<T>
     	return new Iterator<T>()
     	{
     		Node<T> curr = top;
-			@Override
 			public boolean hasNext()
 			{
 				return curr != null;
 			}
 
-			@Override
 			public T next()
 			{
 				T result = curr.data;
@@ -105,7 +103,6 @@ public class SimpleStack<T> implements Iterable<T>
 				return result;
 			}
 
-			@Override
 			public void remove()
 			{
 				throw new UnsupportedOperationException();
